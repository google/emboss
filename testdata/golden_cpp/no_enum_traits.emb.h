/**
 * Generated by the Emboss compiler.  DO NOT EDIT!
 */
#ifndef TESTDATA_NO_ENUM_TRAITS_EMB_H_
#define TESTDATA_NO_ENUM_TRAITS_EMB_H_
#include <stdint.h>
#include <string.h>

#include <algorithm>
#include <type_traits>
#include <utility>

#include "runtime/cpp/emboss_cpp_util.h"

#include "runtime/cpp/emboss_prelude.h"



/* NOLINTBEGIN */
namespace emboss {
namespace test {
enum class Foo : ::std::uint64_t;

namespace Bar {

}  // namespace Bar


template <class Storage>
class GenericBarView;


enum class Foo : ::std::uint64_t {
  VALUE = static_cast</**/::std::int32_t>(10LL),

};



namespace Bar {

}  // namespace Bar


template <class View>
struct EmbossReservedInternalIsGenericBarView;

template <class Storage>
class GenericBarView final {
 public:
  GenericBarView() : backing_() {}
  explicit GenericBarView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericBarView(
      const GenericBarView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericBarView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericBarView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericBarView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericBarView<Storage> &operator=(
      const GenericBarView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!foo().Ok()) return false;
        if (!IntrinsicSizeInBytes().Ok()) return false;
        if (!MaxSizeInBytes().Ok()) return false;
        if (!MinSizeInBytes().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericBarView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_foo().Known()) return false;
    if (!emboss_reserved_local_other.has_foo().Known()) return false;

    if (emboss_reserved_local_other.has_foo().ValueOrDefault() &&
        !has_foo().ValueOrDefault())
      return false;
    if (has_foo().ValueOrDefault() &&
        !emboss_reserved_local_other.has_foo().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_foo().ValueOrDefault() &&
        has_foo().ValueOrDefault() &&
        !foo().Equals(emboss_reserved_local_other.foo()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericBarView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_foo().ValueOr(false) &&
        !has_foo().ValueOr(false))
      return false;
    if (has_foo().ValueOr(false) &&
        !emboss_reserved_local_other.has_foo().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_foo().ValueOr(false) &&
        has_foo().ValueOr(false) &&
        !foo().UncheckedEquals(emboss_reserved_local_other.foo()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericBarView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericBarView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericBarView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::support::EnumView<
    /**/ ::emboss::test::Foo,
    ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 foo() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_foo() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericBarView;
};
using BarView =
    GenericBarView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using BarWriter =
    GenericBarView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericBarView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericBarView<
    GenericBarView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericBarView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeBarView( T &&emboss_reserved_local_arg) {
  return GenericBarView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericBarView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeBarView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericBarView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericBarView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedBarView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericBarView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

namespace Bar {

}  // namespace Bar


template <class Storage>
inline typename ::emboss::support::EnumView<
    /**/ ::emboss::test::Foo,
    ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericBarView<Storage>::foo()
    const {

  if ( has_foo().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::support::EnumView<
    /**/ ::emboss::test::Foo,
    ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::support::EnumView<
    /**/ ::emboss::test::Foo,
    ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericBarView<Storage>::has_foo() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace Bar {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace Bar

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return Bar::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return Bar::IntrinsicSizeInBytes();
}

namespace Bar {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace Bar

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return Bar::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return Bar::MaxSizeInBytes();
}

namespace Bar {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace Bar

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return Bar::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBarView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return Bar::MinSizeInBytes();
}



}  // namespace test



}  // namespace emboss



/* NOLINTEND */

#endif  // TESTDATA_NO_ENUM_TRAITS_EMB_H_

