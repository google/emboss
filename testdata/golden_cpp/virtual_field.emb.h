/**
 * Generated by the Emboss compiler.  DO NOT EDIT!
 */
#ifndef TESTDATA_VIRTUAL_FIELD_EMB_H_
#define TESTDATA_VIRTUAL_FIELD_EMB_H_
#include <stdint.h>
#include <string.h>

#include <algorithm>
#include <type_traits>
#include <utility>

#include "runtime/cpp/emboss_cpp_util.h"

#include "runtime/cpp/emboss_prelude.h"

#include "runtime/cpp/emboss_enum_view.h"

#include "runtime/cpp/emboss_text_util.h"



/* NOLINTBEGIN */
namespace emboss {
namespace test {
namespace StructureWithConstants {

}  // namespace StructureWithConstants


template <class Storage>
class GenericStructureWithConstantsView;

namespace StructureWithComputedValues {

}  // namespace StructureWithComputedValues


template <class Storage>
class GenericStructureWithComputedValuesView;

namespace StructureWithConditionalValue {

}  // namespace StructureWithConditionalValue


template <class Storage>
class GenericStructureWithConditionalValueView;

namespace StructureWithValueInCondition {

}  // namespace StructureWithValueInCondition


template <class Storage>
class GenericStructureWithValueInConditionView;

namespace StructureWithValuesInLocation {

}  // namespace StructureWithValuesInLocation


template <class Storage>
class GenericStructureWithValuesInLocationView;

namespace StructureWithBoolValue {

}  // namespace StructureWithBoolValue


template <class Storage>
class GenericStructureWithBoolValueView;

namespace StructureWithEnumValue {
enum class Category : ::std::uint64_t;


}  // namespace StructureWithEnumValue


template <class Storage>
class GenericStructureWithEnumValueView;

namespace StructureWithBitsWithValue {

}  // namespace StructureWithBitsWithValue


template <class Storage>
class GenericStructureWithBitsWithValueView;

namespace BitsWithValue {

}  // namespace BitsWithValue


template <class Storage>
class GenericBitsWithValueView;

namespace StructureUsingForeignConstants {

}  // namespace StructureUsingForeignConstants


template <class Storage>
class GenericStructureUsingForeignConstantsView;

namespace SubfieldOfAlias {
namespace Header {

}  // namespace Header


template <class Storage>
class GenericHeaderView;


}  // namespace SubfieldOfAlias


template <class Storage>
class GenericSubfieldOfAliasView;

namespace RestrictedAlias {

}  // namespace RestrictedAlias


template <class Storage>
class GenericRestrictedAliasView;

namespace HasField {
namespace X {

}  // namespace X


template <class Storage>
class GenericXView;


}  // namespace HasField


template <class Storage>
class GenericHasFieldView;

namespace VirtualUnconditionallyUsesConditional {

}  // namespace VirtualUnconditionallyUsesConditional


template <class Storage>
class GenericVirtualUnconditionallyUsesConditionalView;

namespace UsesSize {
namespace R {

}  // namespace R


template <class Storage>
class GenericRView;


}  // namespace UsesSize


template <class Storage>
class GenericUsesSizeView;

namespace UsesExternalSize {

}  // namespace UsesExternalSize


template <class Storage>
class GenericUsesExternalSizeView;

namespace ImplicitWriteBack {

}  // namespace ImplicitWriteBack


template <class Storage>
class GenericImplicitWriteBackView;














namespace StructureWithConstants {

}  // namespace StructureWithConstants


template <class View>
struct EmbossReservedInternalIsGenericStructureWithConstantsView;

template <class Storage>
class GenericStructureWithConstantsView final {
 public:
  GenericStructureWithConstantsView() : backing_() {}
  explicit GenericStructureWithConstantsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithConstantsView(
      const GenericStructureWithConstantsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithConstantsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithConstantsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithConstantsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithConstantsView<Storage> &operator=(
      const GenericStructureWithConstantsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !twenty().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !four_billion().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !ten_billion().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !minus_ten_billion().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !value().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_value().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_alias_of_value().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_alias_of_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithConstantsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_value().Known()) return false;
    if (!emboss_reserved_local_other.has_value().Known()) return false;

    if (emboss_reserved_local_other.has_value().ValueOrDefault() &&
        !has_value().ValueOrDefault())
      return false;
    if (has_value().ValueOrDefault() &&
        !emboss_reserved_local_other.has_value().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_value().ValueOrDefault() &&
        has_value().ValueOrDefault() &&
        !value().Equals(emboss_reserved_local_other.value()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithConstantsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_value().ValueOr(false) &&
        !has_value().ValueOr(false))
      return false;
    if (has_value().ValueOr(false) &&
        !emboss_reserved_local_other.has_value().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_value().ValueOr(false) &&
        has_value().ValueOr(false) &&
        !value().UncheckedEquals(emboss_reserved_local_other.value()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithConstantsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithConstantsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithConstantsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "value") {
        if (!value().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "alias_of_value") {
        if (!alias_of_value().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "alias_of_alias_of_value") {
        if (!alias_of_alias_of_value().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_ten().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          ten().IsAggregate() || ten().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# ten: ");
        ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# ten: UNREADABLE\n");
      }
    }

    if (has_twenty().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          twenty().IsAggregate() || twenty().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# twenty: ");
        twenty().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# twenty: UNREADABLE\n");
      }
    }

    if (has_four_billion().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          four_billion().IsAggregate() || four_billion().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# four_billion: ");
        four_billion().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# four_billion: UNREADABLE\n");
      }
    }

    if (has_ten_billion().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          ten_billion().IsAggregate() || ten_billion().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# ten_billion: ");
        ten_billion().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# ten_billion: UNREADABLE\n");
      }
    }

    if (has_minus_ten_billion().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          minus_ten_billion().IsAggregate() || minus_ten_billion().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# minus_ten_billion: ");
        minus_ten_billion().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# minus_ten_billion: UNREADABLE\n");
      }
    }

    if (has_value().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          value().IsAggregate() || value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("value: ");
        value().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !value().IsAggregate() && !value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# value: UNREADABLE\n");
      }
    }

    if (has_alias_of_value().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_value().IsAggregate() || alias_of_value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("alias_of_value: ");
        alias_of_value().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !alias_of_value().IsAggregate() && !alias_of_value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_value: UNREADABLE\n");
      }
    }

    if (has_alias_of_alias_of_value().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_alias_of_value().IsAggregate() || alias_of_alias_of_value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("alias_of_alias_of_value: ");
        alias_of_alias_of_value().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !alias_of_alias_of_value().IsAggregate() && !alias_of_alias_of_value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_alias_of_value: UNREADABLE\n");
      }
    }

    if (has_alias_of_ten().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_ten().IsAggregate() || alias_of_ten().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# alias_of_ten: ");
        alias_of_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_ten: UNREADABLE\n");
      }
    }

    if (has_alias_of_alias_of_ten().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_alias_of_ten().IsAggregate() || alias_of_alias_of_ten().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# alias_of_alias_of_ten: ");
        alias_of_alias_of_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_alias_of_ten: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  class EmbossReservedVirtualTenView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedVirtualTenView() {}
    EmbossReservedVirtualTenView(const EmbossReservedVirtualTenView &) = default;
    EmbossReservedVirtualTenView(EmbossReservedVirtualTenView &&) = default;
    EmbossReservedVirtualTenView &operator=(const EmbossReservedVirtualTenView &) =
        default;
    EmbossReservedVirtualTenView &operator=(EmbossReservedVirtualTenView &&) =
        default;
    ~EmbossReservedVirtualTenView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualTenView ten() {
    return EmbossReservedVirtualTenView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_ten() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualTwentyView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedVirtualTwentyView() {}
    EmbossReservedVirtualTwentyView(const EmbossReservedVirtualTwentyView &) = default;
    EmbossReservedVirtualTwentyView(EmbossReservedVirtualTwentyView &&) = default;
    EmbossReservedVirtualTwentyView &operator=(const EmbossReservedVirtualTwentyView &) =
        default;
    EmbossReservedVirtualTwentyView &operator=(EmbossReservedVirtualTwentyView &&) =
        default;
    ~EmbossReservedVirtualTwentyView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualTwentyView twenty() {
    return EmbossReservedVirtualTwentyView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_twenty() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualFourBillionView final {
   public:
    using ValueType = ::std::uint32_t;

    constexpr EmbossReservedVirtualFourBillionView() {}
    EmbossReservedVirtualFourBillionView(const EmbossReservedVirtualFourBillionView &) = default;
    EmbossReservedVirtualFourBillionView(EmbossReservedVirtualFourBillionView &&) = default;
    EmbossReservedVirtualFourBillionView &operator=(const EmbossReservedVirtualFourBillionView &) =
        default;
    EmbossReservedVirtualFourBillionView &operator=(EmbossReservedVirtualFourBillionView &&) =
        default;
    ~EmbossReservedVirtualFourBillionView() = default;

    static constexpr ::std::uint32_t Read();
    static constexpr ::std::uint32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualFourBillionView four_billion() {
    return EmbossReservedVirtualFourBillionView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_four_billion() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualTenBillionView final {
   public:
    using ValueType = ::std::int64_t;

    constexpr EmbossReservedVirtualTenBillionView() {}
    EmbossReservedVirtualTenBillionView(const EmbossReservedVirtualTenBillionView &) = default;
    EmbossReservedVirtualTenBillionView(EmbossReservedVirtualTenBillionView &&) = default;
    EmbossReservedVirtualTenBillionView &operator=(const EmbossReservedVirtualTenBillionView &) =
        default;
    EmbossReservedVirtualTenBillionView &operator=(EmbossReservedVirtualTenBillionView &&) =
        default;
    ~EmbossReservedVirtualTenBillionView() = default;

    static constexpr ::std::int64_t Read();
    static constexpr ::std::int64_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualTenBillionView ten_billion() {
    return EmbossReservedVirtualTenBillionView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_ten_billion() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualMinusTenBillionView final {
   public:
    using ValueType = ::std::int64_t;

    constexpr EmbossReservedVirtualMinusTenBillionView() {}
    EmbossReservedVirtualMinusTenBillionView(const EmbossReservedVirtualMinusTenBillionView &) = default;
    EmbossReservedVirtualMinusTenBillionView(EmbossReservedVirtualMinusTenBillionView &&) = default;
    EmbossReservedVirtualMinusTenBillionView &operator=(const EmbossReservedVirtualMinusTenBillionView &) =
        default;
    EmbossReservedVirtualMinusTenBillionView &operator=(EmbossReservedVirtualMinusTenBillionView &&) =
        default;
    ~EmbossReservedVirtualMinusTenBillionView() = default;

    static constexpr ::std::int64_t Read();
    static constexpr ::std::int64_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualMinusTenBillionView minus_ten_billion() {
    return EmbossReservedVirtualMinusTenBillionView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_minus_ten_billion() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 value() const;
  ::emboss::support::Maybe<bool> has_value() const;

 public:
  auto alias_of_value() const -> decltype(this->value()) {
   return has_alias_of_value().ValueOrDefault() ? value()
                                          : decltype(this->value())();
  }
  ::emboss::support::Maybe<bool> has_alias_of_value() const;

 public:
  auto alias_of_alias_of_value() const -> decltype(this->alias_of_value()) {
   return has_alias_of_alias_of_value().ValueOrDefault() ? alias_of_value()
                                          : decltype(this->alias_of_value())();
  }
  ::emboss::support::Maybe<bool> has_alias_of_alias_of_value() const;

 public:
  class EmbossReservedVirtualAliasOfTenView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedVirtualAliasOfTenView() {}
    EmbossReservedVirtualAliasOfTenView(const EmbossReservedVirtualAliasOfTenView &) = default;
    EmbossReservedVirtualAliasOfTenView(EmbossReservedVirtualAliasOfTenView &&) = default;
    EmbossReservedVirtualAliasOfTenView &operator=(const EmbossReservedVirtualAliasOfTenView &) =
        default;
    EmbossReservedVirtualAliasOfTenView &operator=(EmbossReservedVirtualAliasOfTenView &&) =
        default;
    ~EmbossReservedVirtualAliasOfTenView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualAliasOfTenView alias_of_ten() {
    return EmbossReservedVirtualAliasOfTenView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_alias_of_ten() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualAliasOfAliasOfTenView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedVirtualAliasOfAliasOfTenView() {}
    EmbossReservedVirtualAliasOfAliasOfTenView(const EmbossReservedVirtualAliasOfAliasOfTenView &) = default;
    EmbossReservedVirtualAliasOfAliasOfTenView(EmbossReservedVirtualAliasOfAliasOfTenView &&) = default;
    EmbossReservedVirtualAliasOfAliasOfTenView &operator=(const EmbossReservedVirtualAliasOfAliasOfTenView &) =
        default;
    EmbossReservedVirtualAliasOfAliasOfTenView &operator=(EmbossReservedVirtualAliasOfAliasOfTenView &&) =
        default;
    ~EmbossReservedVirtualAliasOfAliasOfTenView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualAliasOfAliasOfTenView alias_of_alias_of_ten() {
    return EmbossReservedVirtualAliasOfAliasOfTenView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_alias_of_alias_of_ten() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithConstantsView;
};
using StructureWithConstantsView =
    GenericStructureWithConstantsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithConstantsWriter =
    GenericStructureWithConstantsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithConstantsView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithConstantsView<
    GenericStructureWithConstantsView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithConstantsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithConstantsView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithConstantsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithConstantsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithConstantsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithConstantsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithConstantsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithConstantsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithConstantsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}









namespace StructureWithComputedValues {

}  // namespace StructureWithComputedValues


template <class View>
struct EmbossReservedInternalIsGenericStructureWithComputedValuesView;

template <class Storage>
class GenericStructureWithComputedValuesView final {
 public:
  GenericStructureWithComputedValuesView() : backing_() {}
  explicit GenericStructureWithComputedValuesView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithComputedValuesView(
      const GenericStructureWithComputedValuesView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithComputedValuesView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithComputedValuesView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithComputedValuesView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithComputedValuesView<Storage> &operator=(
      const GenericStructureWithComputedValuesView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !value().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !doubled().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !plus_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !value2().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !signed_doubled().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !signed_plus_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !product().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithComputedValuesView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_value().Known()) return false;
    if (!emboss_reserved_local_other.has_value().Known()) return false;

    if (emboss_reserved_local_other.has_value().ValueOrDefault() &&
        !has_value().ValueOrDefault())
      return false;
    if (has_value().ValueOrDefault() &&
        !emboss_reserved_local_other.has_value().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_value().ValueOrDefault() &&
        has_value().ValueOrDefault() &&
        !value().Equals(emboss_reserved_local_other.value()))
      return false;



    if (!has_value2().Known()) return false;
    if (!emboss_reserved_local_other.has_value2().Known()) return false;

    if (emboss_reserved_local_other.has_value2().ValueOrDefault() &&
        !has_value2().ValueOrDefault())
      return false;
    if (has_value2().ValueOrDefault() &&
        !emboss_reserved_local_other.has_value2().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_value2().ValueOrDefault() &&
        has_value2().ValueOrDefault() &&
        !value2().Equals(emboss_reserved_local_other.value2()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithComputedValuesView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_value().ValueOr(false) &&
        !has_value().ValueOr(false))
      return false;
    if (has_value().ValueOr(false) &&
        !emboss_reserved_local_other.has_value().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_value().ValueOr(false) &&
        has_value().ValueOr(false) &&
        !value().UncheckedEquals(emboss_reserved_local_other.value()))
      return false;



    if (emboss_reserved_local_other.has_value2().ValueOr(false) &&
        !has_value2().ValueOr(false))
      return false;
    if (has_value2().ValueOr(false) &&
        !emboss_reserved_local_other.has_value2().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_value2().ValueOr(false) &&
        has_value2().ValueOr(false) &&
        !value2().UncheckedEquals(emboss_reserved_local_other.value2()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithComputedValuesView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithComputedValuesView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithComputedValuesView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "value") {
        if (!value().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "plus_ten") {
        if (!plus_ten().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "value2") {
        if (!value2().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "signed_plus_ten") {
        if (!signed_plus_ten().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_value().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          value().IsAggregate() || value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("value: ");
        value().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !value().IsAggregate() && !value().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# value: UNREADABLE\n");
      }
    }

    if (has_doubled().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          doubled().IsAggregate() || doubled().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# doubled: ");
        doubled().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# doubled: UNREADABLE\n");
      }
    }

    if (has_plus_ten().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          plus_ten().IsAggregate() || plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("plus_ten: ");
        plus_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !plus_ten().IsAggregate() && !plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# plus_ten: UNREADABLE\n");
      }
    }

    if (has_value2().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          value2().IsAggregate() || value2().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("value2: ");
        value2().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !value2().IsAggregate() && !value2().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# value2: UNREADABLE\n");
      }
    }

    if (has_signed_doubled().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          signed_doubled().IsAggregate() || signed_doubled().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# signed_doubled: ");
        signed_doubled().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# signed_doubled: UNREADABLE\n");
      }
    }

    if (has_signed_plus_ten().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          signed_plus_ten().IsAggregate() || signed_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("signed_plus_ten: ");
        signed_plus_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !signed_plus_ten().IsAggregate() && !signed_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# signed_plus_ten: UNREADABLE\n");
      }
    }

    if (has_product().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          product().IsAggregate() || product().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# product: ");
        product().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# product: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 value() const;
  ::emboss::support::Maybe<bool> has_value() const;

 public:
  class EmbossReservedVirtualDoubledView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualDoubledView(
        const GenericStructureWithComputedValuesView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualDoubledView() = delete;
    EmbossReservedVirtualDoubledView(const EmbossReservedVirtualDoubledView &) = default;
    EmbossReservedVirtualDoubledView(EmbossReservedVirtualDoubledView &&) = default;
    EmbossReservedVirtualDoubledView &operator=(const EmbossReservedVirtualDoubledView &) =
        default;
    EmbossReservedVirtualDoubledView &operator=(EmbossReservedVirtualDoubledView &&) =
        default;
    ~EmbossReservedVirtualDoubledView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_doubled().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.value();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithComputedValuesView view_;
  };
  EmbossReservedVirtualDoubledView doubled() const;
  ::emboss::support::Maybe<bool> has_doubled() const;

 public:
  class EmbossReservedVirtualPlusTenView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualPlusTenView(
        const GenericStructureWithComputedValuesView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualPlusTenView() = delete;
    EmbossReservedVirtualPlusTenView(const EmbossReservedVirtualPlusTenView &) = default;
    EmbossReservedVirtualPlusTenView(EmbossReservedVirtualPlusTenView &&) = default;
    EmbossReservedVirtualPlusTenView &operator=(const EmbossReservedVirtualPlusTenView &) =
        default;
    EmbossReservedVirtualPlusTenView &operator=(EmbossReservedVirtualPlusTenView &&) =
        default;
    ~EmbossReservedVirtualPlusTenView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_plus_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int64_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.value().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int64_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int64_t emboss_reserved_local_value) {
      view_.value().UncheckedWrite((::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int64_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.value().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.value();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithComputedValuesView view_;
  };
  EmbossReservedVirtualPlusTenView plus_ten() const;
  ::emboss::support::Maybe<bool> has_plus_ten() const;

 public:
  typename ::emboss::prelude::IntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 value2() const;
  ::emboss::support::Maybe<bool> has_value2() const;

 public:
  class EmbossReservedVirtualSignedDoubledView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualSignedDoubledView(
        const GenericStructureWithComputedValuesView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualSignedDoubledView() = delete;
    EmbossReservedVirtualSignedDoubledView(const EmbossReservedVirtualSignedDoubledView &) = default;
    EmbossReservedVirtualSignedDoubledView(EmbossReservedVirtualSignedDoubledView &&) = default;
    EmbossReservedVirtualSignedDoubledView &operator=(const EmbossReservedVirtualSignedDoubledView &) =
        default;
    EmbossReservedVirtualSignedDoubledView &operator=(EmbossReservedVirtualSignedDoubledView &&) =
        default;
    ~EmbossReservedVirtualSignedDoubledView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_signed_doubled().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.value2();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithComputedValuesView view_;
  };
  EmbossReservedVirtualSignedDoubledView signed_doubled() const;
  ::emboss::support::Maybe<bool> has_signed_doubled() const;

 public:
  class EmbossReservedVirtualSignedPlusTenView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualSignedPlusTenView(
        const GenericStructureWithComputedValuesView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualSignedPlusTenView() = delete;
    EmbossReservedVirtualSignedPlusTenView(const EmbossReservedVirtualSignedPlusTenView &) = default;
    EmbossReservedVirtualSignedPlusTenView(EmbossReservedVirtualSignedPlusTenView &&) = default;
    EmbossReservedVirtualSignedPlusTenView &operator=(const EmbossReservedVirtualSignedPlusTenView &) =
        default;
    EmbossReservedVirtualSignedPlusTenView &operator=(EmbossReservedVirtualSignedPlusTenView &&) =
        default;
    ~EmbossReservedVirtualSignedPlusTenView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_signed_plus_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int64_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::int32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.value2().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int64_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int64_t emboss_reserved_local_value) {
      view_.value2().UncheckedWrite((::emboss::support::Difference</**/::std::int64_t, ::std::int32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int64_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::int32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.value2().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.value2();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int64_t, ::std::int64_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithComputedValuesView view_;
  };
  EmbossReservedVirtualSignedPlusTenView signed_plus_ten() const;
  ::emboss::support::Maybe<bool> has_signed_plus_ten() const;

 public:
  class EmbossReservedVirtualProductView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualProductView(
        const GenericStructureWithComputedValuesView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualProductView() = delete;
    EmbossReservedVirtualProductView(const EmbossReservedVirtualProductView &) = default;
    EmbossReservedVirtualProductView(EmbossReservedVirtualProductView &&) = default;
    EmbossReservedVirtualProductView &operator=(const EmbossReservedVirtualProductView &) =
        default;
    EmbossReservedVirtualProductView &operator=(EmbossReservedVirtualProductView &&) =
        default;
    ~EmbossReservedVirtualProductView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_product().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.value();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = view_.value2();
      const auto emboss_reserved_local_subexpr_4 = (emboss_reserved_local_subexpr_3.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_3.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithComputedValuesView view_;
  };
  EmbossReservedVirtualProductView product() const;
  ::emboss::support::Maybe<bool> has_product() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithComputedValuesView;
};
using StructureWithComputedValuesView =
    GenericStructureWithComputedValuesView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithComputedValuesWriter =
    GenericStructureWithComputedValuesView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithComputedValuesView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithComputedValuesView<
    GenericStructureWithComputedValuesView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithComputedValuesView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithComputedValuesView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithComputedValuesView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithComputedValuesView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithComputedValuesView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithComputedValuesView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithComputedValuesView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithComputedValuesView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithComputedValuesView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace StructureWithConditionalValue {

}  // namespace StructureWithConditionalValue


template <class View>
struct EmbossReservedInternalIsGenericStructureWithConditionalValueView;

template <class Storage>
class GenericStructureWithConditionalValueView final {
 public:
  GenericStructureWithConditionalValueView() : backing_() {}
  explicit GenericStructureWithConditionalValueView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithConditionalValueView(
      const GenericStructureWithConditionalValueView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithConditionalValueView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithConditionalValueView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithConditionalValueView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithConditionalValueView<Storage> &operator=(
      const GenericStructureWithConditionalValueView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::LessThan</**/::std::uint32_t, bool, ::std::uint32_t, ::std::uint32_t>((x().Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>()), ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(2147483648ULL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !two_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_plus_one().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithConditionalValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithConditionalValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithConditionalValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithConditionalValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithConditionalValueView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "x_plus_one") {
        if (!x_plus_one().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_two_x().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          two_x().IsAggregate() || two_x().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# two_x: ");
        two_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# two_x: UNREADABLE\n");
      }
    }

    if (has_x_plus_one().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_plus_one().IsAggregate() || x_plus_one().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x_plus_one: ");
        x_plus_one().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x_plus_one().IsAggregate() && !x_plus_one().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_plus_one: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualTwoXView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualTwoXView(
        const GenericStructureWithConditionalValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTwoXView() = delete;
    EmbossReservedVirtualTwoXView(const EmbossReservedVirtualTwoXView &) = default;
    EmbossReservedVirtualTwoXView(EmbossReservedVirtualTwoXView &&) = default;
    EmbossReservedVirtualTwoXView &operator=(const EmbossReservedVirtualTwoXView &) =
        default;
    EmbossReservedVirtualTwoXView &operator=(EmbossReservedVirtualTwoXView &&) =
        default;
    ~EmbossReservedVirtualTwoXView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_two_x().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithConditionalValueView view_;
  };
  EmbossReservedVirtualTwoXView two_x() const;
  ::emboss::support::Maybe<bool> has_two_x() const;

 public:
  class EmbossReservedVirtualXPlusOneView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualXPlusOneView(
        const GenericStructureWithConditionalValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXPlusOneView() = delete;
    EmbossReservedVirtualXPlusOneView(const EmbossReservedVirtualXPlusOneView &) = default;
    EmbossReservedVirtualXPlusOneView(EmbossReservedVirtualXPlusOneView &&) = default;
    EmbossReservedVirtualXPlusOneView &operator=(const EmbossReservedVirtualXPlusOneView &) =
        default;
    EmbossReservedVirtualXPlusOneView &operator=(EmbossReservedVirtualXPlusOneView &&) =
        default;
    ~EmbossReservedVirtualXPlusOneView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_x_plus_one().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int64_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int64_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int64_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int64_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int64_t, ::std::uint32_t, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithConditionalValueView view_;
  };
  EmbossReservedVirtualXPlusOneView x_plus_one() const;
  ::emboss::support::Maybe<bool> has_x_plus_one() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithConditionalValueView;
};
using StructureWithConditionalValueView =
    GenericStructureWithConditionalValueView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithConditionalValueWriter =
    GenericStructureWithConditionalValueView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithConditionalValueView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithConditionalValueView<
    GenericStructureWithConditionalValueView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithConditionalValueView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithConditionalValueView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithConditionalValueView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithConditionalValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithConditionalValueView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithConditionalValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithConditionalValueView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithConditionalValueView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithConditionalValueView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace StructureWithValueInCondition {

}  // namespace StructureWithValueInCondition


template <class View>
struct EmbossReservedInternalIsGenericStructureWithValueInConditionView;

template <class Storage>
class GenericStructureWithValueInConditionView final {
 public:
  GenericStructureWithValueInConditionView() : backing_() {}
  explicit GenericStructureWithValueInConditionView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithValueInConditionView(
      const GenericStructureWithValueInConditionView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithValueInConditionView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithValueInConditionView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithValueInConditionView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithValueInConditionView<Storage> &operator=(
      const GenericStructureWithValueInConditionView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !two_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::LessThan</**/::std::int64_t, bool, ::std::int64_t, ::std::int32_t>((two_x().Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(two_x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !if_two_x_lt_100().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithValueInConditionView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;



    if (!has_if_two_x_lt_100().Known()) return false;
    if (!emboss_reserved_local_other.has_if_two_x_lt_100().Known()) return false;

    if (emboss_reserved_local_other.has_if_two_x_lt_100().ValueOrDefault() &&
        !has_if_two_x_lt_100().ValueOrDefault())
      return false;
    if (has_if_two_x_lt_100().ValueOrDefault() &&
        !emboss_reserved_local_other.has_if_two_x_lt_100().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_if_two_x_lt_100().ValueOrDefault() &&
        has_if_two_x_lt_100().ValueOrDefault() &&
        !if_two_x_lt_100().Equals(emboss_reserved_local_other.if_two_x_lt_100()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithValueInConditionView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;



    if (emboss_reserved_local_other.has_if_two_x_lt_100().ValueOr(false) &&
        !has_if_two_x_lt_100().ValueOr(false))
      return false;
    if (has_if_two_x_lt_100().ValueOr(false) &&
        !emboss_reserved_local_other.has_if_two_x_lt_100().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_if_two_x_lt_100().ValueOr(false) &&
        has_if_two_x_lt_100().ValueOr(false) &&
        !if_two_x_lt_100().UncheckedEquals(emboss_reserved_local_other.if_two_x_lt_100()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithValueInConditionView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithValueInConditionView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithValueInConditionView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "if_two_x_lt_100") {
        if (!if_two_x_lt_100().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_two_x().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          two_x().IsAggregate() || two_x().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# two_x: ");
        two_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# two_x: UNREADABLE\n");
      }
    }

    if (has_if_two_x_lt_100().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          if_two_x_lt_100().IsAggregate() || if_two_x_lt_100().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("if_two_x_lt_100: ");
        if_two_x_lt_100().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !if_two_x_lt_100().IsAggregate() && !if_two_x_lt_100().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# if_two_x_lt_100: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualTwoXView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualTwoXView(
        const GenericStructureWithValueInConditionView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTwoXView() = delete;
    EmbossReservedVirtualTwoXView(const EmbossReservedVirtualTwoXView &) = default;
    EmbossReservedVirtualTwoXView(EmbossReservedVirtualTwoXView &&) = default;
    EmbossReservedVirtualTwoXView &operator=(const EmbossReservedVirtualTwoXView &) =
        default;
    EmbossReservedVirtualTwoXView &operator=(EmbossReservedVirtualTwoXView &&) =
        default;
    ~EmbossReservedVirtualTwoXView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_two_x().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithValueInConditionView view_;
  };
  EmbossReservedVirtualTwoXView two_x() const;
  ::emboss::support::Maybe<bool> has_two_x() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 if_two_x_lt_100() const;
  ::emboss::support::Maybe<bool> has_if_two_x_lt_100() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericStructureWithValueInConditionView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.two_x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::LessThan</**/::std::int64_t, bool, ::std::int64_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int32_t, ::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Maximum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)), emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithValueInConditionView view_;
  };
  EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithValueInConditionView;
};
using StructureWithValueInConditionView =
    GenericStructureWithValueInConditionView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithValueInConditionWriter =
    GenericStructureWithValueInConditionView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithValueInConditionView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithValueInConditionView<
    GenericStructureWithValueInConditionView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithValueInConditionView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithValueInConditionView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithValueInConditionView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithValueInConditionView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithValueInConditionView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithValueInConditionView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithValueInConditionView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithValueInConditionView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithValueInConditionView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}






namespace StructureWithValuesInLocation {

}  // namespace StructureWithValuesInLocation


template <class View>
struct EmbossReservedInternalIsGenericStructureWithValuesInLocationView;

template <class Storage>
class GenericStructureWithValuesInLocationView final {
 public:
  GenericStructureWithValuesInLocationView() : backing_() {}
  explicit GenericStructureWithValuesInLocationView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithValuesInLocationView(
      const GenericStructureWithValuesInLocationView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithValuesInLocationView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithValuesInLocationView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithValuesInLocationView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithValuesInLocationView<Storage> &operator=(
      const GenericStructureWithValuesInLocationView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !two_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !offset_two_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !size_two_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithValuesInLocationView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;



    if (!has_offset_two_x().Known()) return false;
    if (!emboss_reserved_local_other.has_offset_two_x().Known()) return false;

    if (emboss_reserved_local_other.has_offset_two_x().ValueOrDefault() &&
        !has_offset_two_x().ValueOrDefault())
      return false;
    if (has_offset_two_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_offset_two_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_offset_two_x().ValueOrDefault() &&
        has_offset_two_x().ValueOrDefault() &&
        !offset_two_x().Equals(emboss_reserved_local_other.offset_two_x()))
      return false;



    if (!has_size_two_x().Known()) return false;
    if (!emboss_reserved_local_other.has_size_two_x().Known()) return false;

    if (emboss_reserved_local_other.has_size_two_x().ValueOrDefault() &&
        !has_size_two_x().ValueOrDefault())
      return false;
    if (has_size_two_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_size_two_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_size_two_x().ValueOrDefault() &&
        has_size_two_x().ValueOrDefault() &&
        !size_two_x().Equals(emboss_reserved_local_other.size_two_x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithValuesInLocationView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;



    if (emboss_reserved_local_other.has_offset_two_x().ValueOr(false) &&
        !has_offset_two_x().ValueOr(false))
      return false;
    if (has_offset_two_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_offset_two_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_offset_two_x().ValueOr(false) &&
        has_offset_two_x().ValueOr(false) &&
        !offset_two_x().UncheckedEquals(emboss_reserved_local_other.offset_two_x()))
      return false;



    if (emboss_reserved_local_other.has_size_two_x().ValueOr(false) &&
        !has_size_two_x().ValueOr(false))
      return false;
    if (has_size_two_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_size_two_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_size_two_x().ValueOr(false) &&
        has_size_two_x().ValueOr(false) &&
        !size_two_x().UncheckedEquals(emboss_reserved_local_other.size_two_x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithValuesInLocationView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithValuesInLocationView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithValuesInLocationView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "offset_two_x") {
        if (!offset_two_x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "size_two_x") {
        if (!size_two_x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_two_x().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          two_x().IsAggregate() || two_x().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# two_x: ");
        two_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# two_x: UNREADABLE\n");
      }
    }

    if (has_offset_two_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          offset_two_x().IsAggregate() || offset_two_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("offset_two_x: ");
        offset_two_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !offset_two_x().IsAggregate() && !offset_two_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# offset_two_x: UNREADABLE\n");
      }
    }

    if (has_size_two_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          size_two_x().IsAggregate() || size_two_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("size_two_x: ");
        size_two_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !size_two_x().IsAggregate() && !size_two_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# size_two_x: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualTwoXView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedVirtualTwoXView(
        const GenericStructureWithValuesInLocationView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTwoXView() = delete;
    EmbossReservedVirtualTwoXView(const EmbossReservedVirtualTwoXView &) = default;
    EmbossReservedVirtualTwoXView(EmbossReservedVirtualTwoXView &&) = default;
    EmbossReservedVirtualTwoXView &operator=(const EmbossReservedVirtualTwoXView &) =
        default;
    EmbossReservedVirtualTwoXView &operator=(EmbossReservedVirtualTwoXView &&) =
        default;
    ~EmbossReservedVirtualTwoXView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_two_x().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Product</**/::std::int64_t, ::std::int64_t, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithValuesInLocationView view_;
  };
  EmbossReservedVirtualTwoXView two_x() const;
  ::emboss::support::Maybe<bool> has_two_x() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/2, 0>>, 32>>

 offset_two_x() const;
  ::emboss::support::Maybe<bool> has_offset_two_x() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 size_two_x() const;
  ::emboss::support::Maybe<bool> has_size_two_x() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int64_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericStructureWithValuesInLocationView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    ::std::int64_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int64_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int64_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.two_x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int64_t, ::std::int64_t, ::std::int64_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int64_t, ::std::int64_t, bool, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/bool>(true), emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Sum</**/::std::int64_t, ::std::int64_t, ::std::int32_t, ::std::int64_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)), emboss_reserved_local_subexpr_2);
      const auto emboss_reserved_local_subexpr_6 = ::emboss::support::Choice</**/::std::int64_t, ::std::int64_t, bool, ::std::int64_t, ::std::int32_t>(::emboss::support::Maybe</**/bool>(true), emboss_reserved_local_subexpr_5, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_7 = ::emboss::support::Maximum</**/::std::int64_t, ::std::int64_t, ::std::int32_t, ::std::int32_t, ::std::int64_t, ::std::int64_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)), emboss_reserved_local_subexpr_4, emboss_reserved_local_subexpr_6);

      return emboss_reserved_local_subexpr_7;
    }

    static constexpr bool ValueIsOk(
        ::std::int64_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithValuesInLocationView view_;
  };
  EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int64_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int64_t Read();
    static constexpr ::std::int64_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithValuesInLocationView;
};
using StructureWithValuesInLocationView =
    GenericStructureWithValuesInLocationView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithValuesInLocationWriter =
    GenericStructureWithValuesInLocationView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithValuesInLocationView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithValuesInLocationView<
    GenericStructureWithValuesInLocationView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithValuesInLocationView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithValuesInLocationView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithValuesInLocationView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithValuesInLocationView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithValuesInLocationView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithValuesInLocationView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithValuesInLocationView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithValuesInLocationView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithValuesInLocationView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace StructureWithBoolValue {

}  // namespace StructureWithBoolValue


template <class View>
struct EmbossReservedInternalIsGenericStructureWithBoolValueView;

template <class Storage>
class GenericStructureWithBoolValueView final {
 public:
  GenericStructureWithBoolValueView() : backing_() {}
  explicit GenericStructureWithBoolValueView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithBoolValueView(
      const GenericStructureWithBoolValueView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithBoolValueView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithBoolValueView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithBoolValueView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithBoolValueView<Storage> &operator=(
      const GenericStructureWithBoolValueView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_is_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithBoolValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithBoolValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithBoolValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithBoolValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithBoolValueView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_x_is_ten().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_is_ten().IsAggregate() || x_is_ten().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# x_is_ten: ");
        x_is_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_is_ten: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualXIsTenView final {
   public:
    using ValueType = bool;

    explicit EmbossReservedVirtualXIsTenView(
        const GenericStructureWithBoolValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXIsTenView() = delete;
    EmbossReservedVirtualXIsTenView(const EmbossReservedVirtualXIsTenView &) = default;
    EmbossReservedVirtualXIsTenView(EmbossReservedVirtualXIsTenView &&) = default;
    EmbossReservedVirtualXIsTenView &operator=(const EmbossReservedVirtualXIsTenView &) =
        default;
    EmbossReservedVirtualXIsTenView &operator=(EmbossReservedVirtualXIsTenView &&) =
        default;
    ~EmbossReservedVirtualXIsTenView() = default;

    bool Read() const {
      EMBOSS_CHECK(view_.has_x_is_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    bool UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteBooleanViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ bool> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Equal</**/::std::uint32_t, bool, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        bool emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithBoolValueView view_;
  };
  EmbossReservedVirtualXIsTenView x_is_ten() const;
  ::emboss::support::Maybe<bool> has_x_is_ten() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithBoolValueView;
};
using StructureWithBoolValueView =
    GenericStructureWithBoolValueView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithBoolValueWriter =
    GenericStructureWithBoolValueView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithBoolValueView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithBoolValueView<
    GenericStructureWithBoolValueView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithBoolValueView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithBoolValueView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithBoolValueView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithBoolValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithBoolValueView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithBoolValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithBoolValueView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithBoolValueView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithBoolValueView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace StructureWithEnumValue {
enum class Category : ::std::uint64_t {
  SMALL = static_cast</**/::std::int32_t>(1LL),
  LARGE = static_cast</**/::std::int32_t>(2LL),

};
template <class Enum>
class EnumTraits;

template <>
class EnumTraits<Category> final {
 public:
  static bool TryToGetEnumFromName(const char *emboss_reserved_local_name,
                                   Category *emboss_reserved_local_result) {
    if (emboss_reserved_local_name == nullptr) return false;
    if (!strcmp("SMALL", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = Category::SMALL;
      return true;
    }

    if (!strcmp("LARGE", emboss_reserved_local_name)) {
      *emboss_reserved_local_result = Category::LARGE;
      return true;
    }

    return false;
  }

  static const char *TryToGetNameFromEnum(
      Category emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case Category::SMALL: return "SMALL";

      case Category::LARGE: return "LARGE";

      default: return nullptr;
    }
  }

  static bool EnumIsKnown(Category emboss_reserved_local_value) {
    switch (emboss_reserved_local_value) {
      case Category::SMALL: return true;

      case Category::LARGE: return true;

      default:
        return false;
    }
  }

  static ::std::ostream &SendToOstream(::std::ostream &emboss_reserved_local_os,
                                       Category emboss_reserved_local_value) {
    const char *emboss_reserved_local_name =
        TryToGetNameFromEnum(emboss_reserved_local_value);
    if (emboss_reserved_local_name == nullptr) {
      emboss_reserved_local_os
          << static_cast</**/ ::std::underlying_type<Category>::type>(
                 emboss_reserved_local_value);
    } else {
      emboss_reserved_local_os << emboss_reserved_local_name;
    }
    return emboss_reserved_local_os;
  }
};

static inline bool TryToGetEnumFromName(
    const char *emboss_reserved_local_name,
    Category *emboss_reserved_local_result) {
  return EnumTraits<Category>::TryToGetEnumFromName(
      emboss_reserved_local_name, emboss_reserved_local_result);
}

static inline const char *TryToGetNameFromEnum(
    Category emboss_reserved_local_value) {
  return EnumTraits<Category>::TryToGetNameFromEnum(
      emboss_reserved_local_value);
}

static inline bool EnumIsKnown(Category emboss_reserved_local_value) {
  return EnumTraits<Category>::EnumIsKnown(emboss_reserved_local_value);
}

static inline ::std::ostream &operator<<(
    ::std::ostream &emboss_reserved_local_os,
    Category emboss_reserved_local_value) {
  return EnumTraits<Category>::SendToOstream(emboss_reserved_local_os,
                                             emboss_reserved_local_value);
}

}  // namespace StructureWithEnumValue


template <class View>
struct EmbossReservedInternalIsGenericStructureWithEnumValueView;

template <class Storage>
class GenericStructureWithEnumValueView final {
 public:
  GenericStructureWithEnumValueView() : backing_() {}
  explicit GenericStructureWithEnumValueView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithEnumValueView(
      const GenericStructureWithEnumValueView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithEnumValueView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithEnumValueView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithEnumValueView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithEnumValueView<Storage> &operator=(
      const GenericStructureWithEnumValueView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

    using Category = ::emboss::test::StructureWithEnumValue::Category;

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_size().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithEnumValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithEnumValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithEnumValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithEnumValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithEnumValueView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_x_size().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_size().IsAggregate() || x_size().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# x_size: ");
        x_size().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_size: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualXSizeView final {
   public:
    using ValueType = ::emboss::test::StructureWithEnumValue::Category;

    explicit EmbossReservedVirtualXSizeView(
        const GenericStructureWithEnumValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXSizeView() = delete;
    EmbossReservedVirtualXSizeView(const EmbossReservedVirtualXSizeView &) = default;
    EmbossReservedVirtualXSizeView(EmbossReservedVirtualXSizeView &&) = default;
    EmbossReservedVirtualXSizeView &operator=(const EmbossReservedVirtualXSizeView &) =
        default;
    EmbossReservedVirtualXSizeView &operator=(EmbossReservedVirtualXSizeView &&) =
        default;
    ~EmbossReservedVirtualXSizeView() = default;

    ::emboss::test::StructureWithEnumValue::Category Read() const {
      EMBOSS_CHECK(view_.has_x_size().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::emboss::test::StructureWithEnumValue::Category UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteEnumViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::emboss::test::StructureWithEnumValue::Category> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::LessThan</**/::std::uint32_t, bool, ::std::uint32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::emboss::test::StructureWithEnumValue::Category, ::emboss::test::StructureWithEnumValue::Category, bool, ::emboss::test::StructureWithEnumValue::Category, ::emboss::test::StructureWithEnumValue::Category>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::emboss::test::StructureWithEnumValue::Category>(static_cast</**/::emboss::test::StructureWithEnumValue::Category>(1)), ::emboss::support::Maybe</**/::emboss::test::StructureWithEnumValue::Category>(static_cast</**/::emboss::test::StructureWithEnumValue::Category>(2)));

      return emboss_reserved_local_subexpr_4;
    }

    static constexpr bool ValueIsOk(
        ::emboss::test::StructureWithEnumValue::Category emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithEnumValueView view_;
  };
  EmbossReservedVirtualXSizeView x_size() const;
  ::emboss::support::Maybe<bool> has_x_size() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithEnumValueView;
};
using StructureWithEnumValueView =
    GenericStructureWithEnumValueView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithEnumValueWriter =
    GenericStructureWithEnumValueView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithEnumValueView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithEnumValueView<
    GenericStructureWithEnumValueView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithEnumValueView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithEnumValueView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithEnumValueView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithEnumValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithEnumValueView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithEnumValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithEnumValueView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithEnumValueView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithEnumValueView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace StructureWithBitsWithValue {

}  // namespace StructureWithBitsWithValue


template <class View>
struct EmbossReservedInternalIsGenericStructureWithBitsWithValueView;

template <class Storage>
class GenericStructureWithBitsWithValueView final {
 public:
  GenericStructureWithBitsWithValueView() : backing_() {}
  explicit GenericStructureWithBitsWithValueView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureWithBitsWithValueView(
      const GenericStructureWithBitsWithValueView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureWithBitsWithValueView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureWithBitsWithValueView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureWithBitsWithValueView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureWithBitsWithValueView<Storage> &operator=(
      const GenericStructureWithBitsWithValueView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !b().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_b_sum().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_of_b_a().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureWithBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_b().Known()) return false;
    if (!emboss_reserved_local_other.has_b().Known()) return false;

    if (emboss_reserved_local_other.has_b().ValueOrDefault() &&
        !has_b().ValueOrDefault())
      return false;
    if (has_b().ValueOrDefault() &&
        !emboss_reserved_local_other.has_b().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_b().ValueOrDefault() &&
        has_b().ValueOrDefault() &&
        !b().Equals(emboss_reserved_local_other.b()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureWithBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_b().ValueOr(false) &&
        !has_b().ValueOr(false))
      return false;
    if (has_b().ValueOr(false) &&
        !emboss_reserved_local_other.has_b().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_b().ValueOr(false) &&
        has_b().ValueOr(false) &&
        !b().UncheckedEquals(emboss_reserved_local_other.b()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureWithBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureWithBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureWithBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "b") {
        if (!b().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "alias_of_b_a") {
        if (!alias_of_b_a().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_b().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          b().IsAggregate() || b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("b: ");
        b().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !b().IsAggregate() && !b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# b: UNREADABLE\n");
      }
    }

    if (has_alias_of_b_sum().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_b_sum().IsAggregate() || alias_of_b_sum().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# alias_of_b_sum: ");
        alias_of_b_sum().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_b_sum: UNREADABLE\n");
      }
    }

    if (has_alias_of_b_a().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_of_b_a().IsAggregate() || alias_of_b_a().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("alias_of_b_a: ");
        alias_of_b_a().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !alias_of_b_a().IsAggregate() && !alias_of_b_a().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_of_b_a: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 b() const;
  ::emboss::support::Maybe<bool> has_b() const;

 public:
  class EmbossReservedVirtualAliasOfBSumView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualAliasOfBSumView(
        const GenericStructureWithBitsWithValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualAliasOfBSumView() = delete;
    EmbossReservedVirtualAliasOfBSumView(const EmbossReservedVirtualAliasOfBSumView &) = default;
    EmbossReservedVirtualAliasOfBSumView(EmbossReservedVirtualAliasOfBSumView &&) = default;
    EmbossReservedVirtualAliasOfBSumView &operator=(const EmbossReservedVirtualAliasOfBSumView &) =
        default;
    EmbossReservedVirtualAliasOfBSumView &operator=(EmbossReservedVirtualAliasOfBSumView &&) =
        default;
    ~EmbossReservedVirtualAliasOfBSumView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_alias_of_b_sum().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.b().sum();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());

      return emboss_reserved_local_subexpr_2;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructureWithBitsWithValueView view_;
  };
  EmbossReservedVirtualAliasOfBSumView alias_of_b_sum() const;
  ::emboss::support::Maybe<bool> has_alias_of_b_sum() const;

 public:
  auto alias_of_b_a() const -> decltype(this->b().a()) {
   return has_alias_of_b_a().ValueOrDefault() ? b().a()
                                          : decltype(this->b().a())();
  }
  ::emboss::support::Maybe<bool> has_alias_of_b_a() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureWithBitsWithValueView;
};
using StructureWithBitsWithValueView =
    GenericStructureWithBitsWithValueView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureWithBitsWithValueWriter =
    GenericStructureWithBitsWithValueView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureWithBitsWithValueView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureWithBitsWithValueView<
    GenericStructureWithBitsWithValueView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureWithBitsWithValueView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureWithBitsWithValueView( T &&emboss_reserved_local_arg) {
  return GenericStructureWithBitsWithValueView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureWithBitsWithValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureWithBitsWithValueView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithBitsWithValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureWithBitsWithValueView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureWithBitsWithValueView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureWithBitsWithValueView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace BitsWithValue {

}  // namespace BitsWithValue


template <class View>
struct EmbossReservedInternalIsGenericBitsWithValueView;

template <class Storage>
class GenericBitsWithValueView final {
 public:
  GenericBitsWithValueView() : backing_() {}
  explicit GenericBitsWithValueView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericBitsWithValueView(
      const GenericBitsWithValueView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericBitsWithValueView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericBitsWithValueView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericBitsWithValueView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericBitsWithValueView<Storage> &operator=(
      const GenericBitsWithValueView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !a().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !b().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !sum().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBits().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBits().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBits().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_a().Known()) return false;
    if (!emboss_reserved_local_other.has_a().Known()) return false;

    if (emboss_reserved_local_other.has_a().ValueOrDefault() &&
        !has_a().ValueOrDefault())
      return false;
    if (has_a().ValueOrDefault() &&
        !emboss_reserved_local_other.has_a().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_a().ValueOrDefault() &&
        has_a().ValueOrDefault() &&
        !a().Equals(emboss_reserved_local_other.a()))
      return false;



    if (!has_b().Known()) return false;
    if (!emboss_reserved_local_other.has_b().Known()) return false;

    if (emboss_reserved_local_other.has_b().ValueOrDefault() &&
        !has_b().ValueOrDefault())
      return false;
    if (has_b().ValueOrDefault() &&
        !emboss_reserved_local_other.has_b().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_b().ValueOrDefault() &&
        has_b().ValueOrDefault() &&
        !b().Equals(emboss_reserved_local_other.b()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_a().ValueOr(false) &&
        !has_a().ValueOr(false))
      return false;
    if (has_a().ValueOr(false) &&
        !emboss_reserved_local_other.has_a().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_a().ValueOr(false) &&
        has_a().ValueOr(false) &&
        !a().UncheckedEquals(emboss_reserved_local_other.a()))
      return false;



    if (emboss_reserved_local_other.has_b().ValueOr(false) &&
        !has_b().ValueOr(false))
      return false;
    if (has_b().ValueOr(false) &&
        !emboss_reserved_local_other.has_b().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_b().ValueOr(false) &&
        has_b().ValueOr(false) &&
        !b().UncheckedEquals(emboss_reserved_local_other.b()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericBitsWithValueView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "a") {
        if (!a().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "b") {
        if (!b().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_a().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          a().IsAggregate() || a().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("a: ");
        a().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !a().IsAggregate() && !a().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# a: UNREADABLE\n");
      }
    }

    if (has_b().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          b().IsAggregate() || b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("b: ");
        b().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !b().IsAggregate() && !b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# b: UNREADABLE\n");
      }
    }

    if (has_sum().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          sum().IsAggregate() || sum().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# sum: ");
        sum().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# sum: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 a() const;
  ::emboss::support::Maybe<bool> has_a() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 16>>

 b() const;
  ::emboss::support::Maybe<bool> has_b() const;

 public:
  class EmbossReservedVirtualSumView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualSumView(
        const GenericBitsWithValueView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualSumView() = delete;
    EmbossReservedVirtualSumView(const EmbossReservedVirtualSumView &) = default;
    EmbossReservedVirtualSumView(EmbossReservedVirtualSumView &&) = default;
    EmbossReservedVirtualSumView &operator=(const EmbossReservedVirtualSumView &) =
        default;
    EmbossReservedVirtualSumView &operator=(EmbossReservedVirtualSumView &&) =
        default;
    ~EmbossReservedVirtualSumView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_sum().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.a();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = view_.b();
      const auto emboss_reserved_local_subexpr_4 = (emboss_reserved_local_subexpr_3.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_3.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericBitsWithValueView view_;
  };
  EmbossReservedVirtualSumView sum() const;
  ::emboss::support::Maybe<bool> has_sum() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericBitsWithValueView;
};
using BitsWithValueView =
    GenericBitsWithValueView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using BitsWithValueWriter =
    GenericBitsWithValueView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericBitsWithValueView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericBitsWithValueView<
    GenericBitsWithValueView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericBitsWithValueView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeBitsWithValueView( T &&emboss_reserved_local_arg) {
  return GenericBitsWithValueView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericBitsWithValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeBitsWithValueView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericBitsWithValueView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericBitsWithValueView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedBitsWithValueView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericBitsWithValueView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace StructureUsingForeignConstants {

}  // namespace StructureUsingForeignConstants


template <class View>
struct EmbossReservedInternalIsGenericStructureUsingForeignConstantsView;

template <class Storage>
class GenericStructureUsingForeignConstantsView final {
 public:
  GenericStructureUsingForeignConstantsView() : backing_() {}
  explicit GenericStructureUsingForeignConstantsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructureUsingForeignConstantsView(
      const GenericStructureUsingForeignConstantsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructureUsingForeignConstantsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructureUsingForeignConstantsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructureUsingForeignConstantsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructureUsingForeignConstantsView<Storage> &operator=(
      const GenericStructureUsingForeignConstantsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !one_hundred().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericStructureUsingForeignConstantsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericStructureUsingForeignConstantsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructureUsingForeignConstantsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructureUsingForeignConstantsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericStructureUsingForeignConstantsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_one_hundred().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          one_hundred().IsAggregate() || one_hundred().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# one_hundred: ");
        one_hundred().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# one_hundred: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 10>>, 32>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualOneHundredView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedVirtualOneHundredView() {}
    EmbossReservedVirtualOneHundredView(const EmbossReservedVirtualOneHundredView &) = default;
    EmbossReservedVirtualOneHundredView(EmbossReservedVirtualOneHundredView &&) = default;
    EmbossReservedVirtualOneHundredView &operator=(const EmbossReservedVirtualOneHundredView &) =
        default;
    EmbossReservedVirtualOneHundredView &operator=(EmbossReservedVirtualOneHundredView &&) =
        default;
    ~EmbossReservedVirtualOneHundredView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedVirtualOneHundredView one_hundred() {
    return EmbossReservedVirtualOneHundredView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_one_hundred() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructureUsingForeignConstantsView;
};
using StructureUsingForeignConstantsView =
    GenericStructureUsingForeignConstantsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructureUsingForeignConstantsWriter =
    GenericStructureUsingForeignConstantsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructureUsingForeignConstantsView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructureUsingForeignConstantsView<
    GenericStructureUsingForeignConstantsView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericStructureUsingForeignConstantsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructureUsingForeignConstantsView( T &&emboss_reserved_local_arg) {
  return GenericStructureUsingForeignConstantsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericStructureUsingForeignConstantsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructureUsingForeignConstantsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructureUsingForeignConstantsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericStructureUsingForeignConstantsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructureUsingForeignConstantsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructureUsingForeignConstantsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace SubfieldOfAlias {




namespace Header {

}  // namespace Header


template <class View>
struct EmbossReservedInternalIsGenericHeaderView;

template <class Storage>
class GenericHeaderView final {
 public:
  GenericHeaderView() : backing_() {}
  explicit GenericHeaderView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericHeaderView(
      const GenericHeaderView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericHeaderView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericHeaderView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericHeaderView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericHeaderView<Storage> &operator=(
      const GenericHeaderView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !size().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !message_id().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericHeaderView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_size().Known()) return false;
    if (!emboss_reserved_local_other.has_size().Known()) return false;

    if (emboss_reserved_local_other.has_size().ValueOrDefault() &&
        !has_size().ValueOrDefault())
      return false;
    if (has_size().ValueOrDefault() &&
        !emboss_reserved_local_other.has_size().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_size().ValueOrDefault() &&
        has_size().ValueOrDefault() &&
        !size().Equals(emboss_reserved_local_other.size()))
      return false;



    if (!has_message_id().Known()) return false;
    if (!emboss_reserved_local_other.has_message_id().Known()) return false;

    if (emboss_reserved_local_other.has_message_id().ValueOrDefault() &&
        !has_message_id().ValueOrDefault())
      return false;
    if (has_message_id().ValueOrDefault() &&
        !emboss_reserved_local_other.has_message_id().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_message_id().ValueOrDefault() &&
        has_message_id().ValueOrDefault() &&
        !message_id().Equals(emboss_reserved_local_other.message_id()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericHeaderView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_size().ValueOr(false) &&
        !has_size().ValueOr(false))
      return false;
    if (has_size().ValueOr(false) &&
        !emboss_reserved_local_other.has_size().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_size().ValueOr(false) &&
        has_size().ValueOr(false) &&
        !size().UncheckedEquals(emboss_reserved_local_other.size()))
      return false;



    if (emboss_reserved_local_other.has_message_id().ValueOr(false) &&
        !has_message_id().ValueOr(false))
      return false;
    if (has_message_id().ValueOr(false) &&
        !emboss_reserved_local_other.has_message_id().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_message_id().ValueOr(false) &&
        has_message_id().ValueOr(false) &&
        !message_id().UncheckedEquals(emboss_reserved_local_other.message_id()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericHeaderView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericHeaderView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericHeaderView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "size") {
        if (!size().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "message_id") {
        if (!message_id().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_size().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          size().IsAggregate() || size().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("size: ");
        size().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !size().IsAggregate() && !size().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# size: UNREADABLE\n");
      }
    }

    if (has_message_id().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          message_id().IsAggregate() || message_id().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("message_id: ");
        message_id().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !message_id().IsAggregate() && !message_id().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# message_id: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

 size() const;
  ::emboss::support::Maybe<bool> has_size() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 2>>, 16>>

 message_id() const;
  ::emboss::support::Maybe<bool> has_message_id() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericHeaderView;
};
using HeaderView =
    GenericHeaderView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using HeaderWriter =
    GenericHeaderView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericHeaderView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericHeaderView<
    GenericHeaderView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericHeaderView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeHeaderView( T &&emboss_reserved_local_arg) {
  return GenericHeaderView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericHeaderView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeHeaderView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericHeaderView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericHeaderView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedHeaderView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericHeaderView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

}  // namespace SubfieldOfAlias


template <class View>
struct EmbossReservedInternalIsGenericSubfieldOfAliasView;

template <class Storage>
class GenericSubfieldOfAliasView final {
 public:
  GenericSubfieldOfAliasView() : backing_() {}
  explicit GenericSubfieldOfAliasView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericSubfieldOfAliasView(
      const GenericSubfieldOfAliasView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericSubfieldOfAliasView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericSubfieldOfAliasView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericSubfieldOfAliasView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericSubfieldOfAliasView<Storage> &operator=(
      const GenericSubfieldOfAliasView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !header().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !h().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !size().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericSubfieldOfAliasView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_header().Known()) return false;
    if (!emboss_reserved_local_other.has_header().Known()) return false;

    if (emboss_reserved_local_other.has_header().ValueOrDefault() &&
        !has_header().ValueOrDefault())
      return false;
    if (has_header().ValueOrDefault() &&
        !emboss_reserved_local_other.has_header().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_header().ValueOrDefault() &&
        has_header().ValueOrDefault() &&
        !header().Equals(emboss_reserved_local_other.header()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericSubfieldOfAliasView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_header().ValueOr(false) &&
        !has_header().ValueOr(false))
      return false;
    if (has_header().ValueOr(false) &&
        !emboss_reserved_local_other.has_header().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_header().ValueOr(false) &&
        has_header().ValueOr(false) &&
        !header().UncheckedEquals(emboss_reserved_local_other.header()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericSubfieldOfAliasView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericSubfieldOfAliasView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericSubfieldOfAliasView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "header") {
        if (!header().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "h") {
        if (!h().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "size") {
        if (!size().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_header().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          header().IsAggregate() || header().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("header: ");
        header().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !header().IsAggregate() && !header().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# header: UNREADABLE\n");
      }
    }

    if (has_h().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          h().IsAggregate() || h().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("h: ");
        h().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !h().IsAggregate() && !h().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# h: UNREADABLE\n");
      }
    }

    if (has_size().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          size().IsAggregate() || size().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("size: ");
        size().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !size().IsAggregate() && !size().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# size: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::test::SubfieldOfAlias::GenericHeaderView<typename Storage::template OffsetStorageType</**/0, 0>>

 header() const;
  ::emboss::support::Maybe<bool> has_header() const;

 public:
  auto h() const -> decltype(this->header()) {
   return has_h().ValueOrDefault() ? header()
                                          : decltype(this->header())();
  }
  ::emboss::support::Maybe<bool> has_h() const;

 public:
  auto size() const -> decltype(this->h().size()) {
   return has_size().ValueOrDefault() ? h().size()
                                          : decltype(this->h().size())();
  }
  ::emboss::support::Maybe<bool> has_size() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericSubfieldOfAliasView;
};
using SubfieldOfAliasView =
    GenericSubfieldOfAliasView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using SubfieldOfAliasWriter =
    GenericSubfieldOfAliasView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericSubfieldOfAliasView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericSubfieldOfAliasView<
    GenericSubfieldOfAliasView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericSubfieldOfAliasView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeSubfieldOfAliasView( T &&emboss_reserved_local_arg) {
  return GenericSubfieldOfAliasView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericSubfieldOfAliasView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeSubfieldOfAliasView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericSubfieldOfAliasView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericSubfieldOfAliasView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedSubfieldOfAliasView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericSubfieldOfAliasView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace RestrictedAlias {

}  // namespace RestrictedAlias


template <class View>
struct EmbossReservedInternalIsGenericRestrictedAliasView;

template <class Storage>
class GenericRestrictedAliasView final {
 public:
  GenericRestrictedAliasView() : backing_() {}
  explicit GenericRestrictedAliasView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericRestrictedAliasView(
      const GenericRestrictedAliasView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericRestrictedAliasView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericRestrictedAliasView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericRestrictedAliasView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericRestrictedAliasView<Storage> &operator=(
      const GenericRestrictedAliasView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !a_b().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !alias_switch().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((alias_switch().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(alias_switch().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !a_b_alias().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericRestrictedAliasView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_a_b().Known()) return false;
    if (!emboss_reserved_local_other.has_a_b().Known()) return false;

    if (emboss_reserved_local_other.has_a_b().ValueOrDefault() &&
        !has_a_b().ValueOrDefault())
      return false;
    if (has_a_b().ValueOrDefault() &&
        !emboss_reserved_local_other.has_a_b().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_a_b().ValueOrDefault() &&
        has_a_b().ValueOrDefault() &&
        !a_b().Equals(emboss_reserved_local_other.a_b()))
      return false;



    if (!has_alias_switch().Known()) return false;
    if (!emboss_reserved_local_other.has_alias_switch().Known()) return false;

    if (emboss_reserved_local_other.has_alias_switch().ValueOrDefault() &&
        !has_alias_switch().ValueOrDefault())
      return false;
    if (has_alias_switch().ValueOrDefault() &&
        !emboss_reserved_local_other.has_alias_switch().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_alias_switch().ValueOrDefault() &&
        has_alias_switch().ValueOrDefault() &&
        !alias_switch().Equals(emboss_reserved_local_other.alias_switch()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericRestrictedAliasView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_a_b().ValueOr(false) &&
        !has_a_b().ValueOr(false))
      return false;
    if (has_a_b().ValueOr(false) &&
        !emboss_reserved_local_other.has_a_b().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_a_b().ValueOr(false) &&
        has_a_b().ValueOr(false) &&
        !a_b().UncheckedEquals(emboss_reserved_local_other.a_b()))
      return false;



    if (emboss_reserved_local_other.has_alias_switch().ValueOr(false) &&
        !has_alias_switch().ValueOr(false))
      return false;
    if (has_alias_switch().ValueOr(false) &&
        !emboss_reserved_local_other.has_alias_switch().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_alias_switch().ValueOr(false) &&
        has_alias_switch().ValueOr(false) &&
        !alias_switch().UncheckedEquals(emboss_reserved_local_other.alias_switch()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericRestrictedAliasView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericRestrictedAliasView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericRestrictedAliasView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "a_b") {
        if (!a_b().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "alias_switch") {
        if (!alias_switch().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "a_b_alias") {
        if (!a_b_alias().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_a_b().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          a_b().IsAggregate() || a_b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("a_b: ");
        a_b().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !a_b().IsAggregate() && !a_b().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# a_b: UNREADABLE\n");
      }
    }

    if (has_alias_switch().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          alias_switch().IsAggregate() || alias_switch().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("alias_switch: ");
        alias_switch().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !alias_switch().IsAggregate() && !alias_switch().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# alias_switch: UNREADABLE\n");
      }
    }

    if (has_a_b_alias().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          a_b_alias().IsAggregate() || a_b_alias().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("a_b_alias: ");
        a_b_alias().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !a_b_alias().IsAggregate() && !a_b_alias().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# a_b_alias: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 a_b() const;
  ::emboss::support::Maybe<bool> has_a_b() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 8>>

 alias_switch() const;
  ::emboss::support::Maybe<bool> has_alias_switch() const;

 public:
  auto a_b_alias() const -> decltype(this->a_b()) {
   return has_a_b_alias().ValueOrDefault() ? a_b()
                                          : decltype(this->a_b())();
  }
  ::emboss::support::Maybe<bool> has_a_b_alias() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericRestrictedAliasView;
};
using RestrictedAliasView =
    GenericRestrictedAliasView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using RestrictedAliasWriter =
    GenericRestrictedAliasView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericRestrictedAliasView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericRestrictedAliasView<
    GenericRestrictedAliasView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericRestrictedAliasView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeRestrictedAliasView( T &&emboss_reserved_local_arg) {
  return GenericRestrictedAliasView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericRestrictedAliasView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeRestrictedAliasView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericRestrictedAliasView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericRestrictedAliasView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedRestrictedAliasView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericRestrictedAliasView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}






namespace HasField {




namespace X {

}  // namespace X


template <class View>
struct EmbossReservedInternalIsGenericXView;

template <class Storage>
class GenericXView final {
 public:
  GenericXView() : backing_() {}
  explicit GenericXView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericXView(
      const GenericXView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericXView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericXView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericXView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericXView<Storage> &operator=(
      const GenericXView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !v().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((v().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(v().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !y().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  bool Equals(
      GenericXView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_v().Known()) return false;
    if (!emboss_reserved_local_other.has_v().Known()) return false;

    if (emboss_reserved_local_other.has_v().ValueOrDefault() &&
        !has_v().ValueOrDefault())
      return false;
    if (has_v().ValueOrDefault() &&
        !emboss_reserved_local_other.has_v().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_v().ValueOrDefault() &&
        has_v().ValueOrDefault() &&
        !v().Equals(emboss_reserved_local_other.v()))
      return false;



    if (!has_y().Known()) return false;
    if (!emboss_reserved_local_other.has_y().Known()) return false;

    if (emboss_reserved_local_other.has_y().ValueOrDefault() &&
        !has_y().ValueOrDefault())
      return false;
    if (has_y().ValueOrDefault() &&
        !emboss_reserved_local_other.has_y().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_y().ValueOrDefault() &&
        has_y().ValueOrDefault() &&
        !y().Equals(emboss_reserved_local_other.y()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericXView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_v().ValueOr(false) &&
        !has_v().ValueOr(false))
      return false;
    if (has_v().ValueOr(false) &&
        !emboss_reserved_local_other.has_v().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_v().ValueOr(false) &&
        has_v().ValueOr(false) &&
        !v().UncheckedEquals(emboss_reserved_local_other.v()))
      return false;



    if (emboss_reserved_local_other.has_y().ValueOr(false) &&
        !has_y().ValueOr(false))
      return false;
    if (has_y().ValueOr(false) &&
        !emboss_reserved_local_other.has_y().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_y().ValueOr(false) &&
        has_y().ValueOr(false) &&
        !y().UncheckedEquals(emboss_reserved_local_other.y()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericXView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericXView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericXView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "v") {
        if (!v().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "y") {
        if (!y().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_v().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          v().IsAggregate() || v().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("v: ");
        v().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !v().IsAggregate() && !v().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# v: UNREADABLE\n");
      }
    }

    if (has_y().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          y().IsAggregate() || y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("y: ");
        y().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !y().IsAggregate() && !y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# y: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 v() const;
  ::emboss::support::Maybe<bool> has_v() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

 y() const;
  ::emboss::support::Maybe<bool> has_y() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericXView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.v();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int32_t, ::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Maximum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)), emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericXView view_;
  };
  EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericXView;
};
using XView =
    GenericXView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using XWriter =
    GenericXView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericXView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericXView<
    GenericXView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericXView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeXView( T &&emboss_reserved_local_arg) {
  return GenericXView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericXView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeXView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericXView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericXView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedXView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericXView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

}  // namespace HasField


template <class View>
struct EmbossReservedInternalIsGenericHasFieldView;

template <class Storage>
class GenericHasFieldView final {
 public:
  GenericHasFieldView() : backing_() {}
  explicit GenericHasFieldView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericHasFieldView(
      const GenericHasFieldView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericHasFieldView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericHasFieldView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericHasFieldView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericHasFieldView<Storage> &operator=(
      const GenericHasFieldView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !z().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((z().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(z().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = x().has_y();
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !y().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = has_x();
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_has_y().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  bool Equals(
      GenericHasFieldView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_z().Known()) return false;
    if (!emboss_reserved_local_other.has_z().Known()) return false;

    if (emboss_reserved_local_other.has_z().ValueOrDefault() &&
        !has_z().ValueOrDefault())
      return false;
    if (has_z().ValueOrDefault() &&
        !emboss_reserved_local_other.has_z().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_z().ValueOrDefault() &&
        has_z().ValueOrDefault() &&
        !z().Equals(emboss_reserved_local_other.z()))
      return false;



    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericHasFieldView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_z().ValueOr(false) &&
        !has_z().ValueOr(false))
      return false;
    if (has_z().ValueOr(false) &&
        !emboss_reserved_local_other.has_z().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_z().ValueOr(false) &&
        has_z().ValueOr(false) &&
        !z().UncheckedEquals(emboss_reserved_local_other.z()))
      return false;



    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericHasFieldView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericHasFieldView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericHasFieldView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "z") {
        if (!z().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "y") {
        if (!y().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_z().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          z().IsAggregate() || z().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("z: ");
        z().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !z().IsAggregate() && !z().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# z: UNREADABLE\n");
      }
    }

    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_y().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          y().IsAggregate() || y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("y: ");
        y().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !y().IsAggregate() && !y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# y: UNREADABLE\n");
      }
    }

    if (has_x_has_y().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_has_y().IsAggregate() || x_has_y().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# x_has_y: ");
        x_has_y().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_has_y: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 z() const;
  ::emboss::support::Maybe<bool> has_z() const;

 public:
  typename ::emboss::test::HasField::GenericXView<typename Storage::template OffsetStorageType</**/0, 1>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  auto y() const -> decltype(this->x().y()) {
   return has_y().ValueOrDefault() ? x().y()
                                          : decltype(this->x().y())();
  }
  ::emboss::support::Maybe<bool> has_y() const;

 public:
  class EmbossReservedVirtualXHasYView final {
   public:
    using ValueType = bool;

    explicit EmbossReservedVirtualXHasYView(
        const GenericHasFieldView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXHasYView() = delete;
    EmbossReservedVirtualXHasYView(const EmbossReservedVirtualXHasYView &) = default;
    EmbossReservedVirtualXHasYView(EmbossReservedVirtualXHasYView &&) = default;
    EmbossReservedVirtualXHasYView &operator=(const EmbossReservedVirtualXHasYView &) =
        default;
    EmbossReservedVirtualXHasYView &operator=(EmbossReservedVirtualXHasYView &&) =
        default;
    ~EmbossReservedVirtualXHasYView() = default;

    bool Read() const {
      EMBOSS_CHECK(view_.has_x_has_y().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    bool UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteBooleanViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ bool> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x().has_y();

      return emboss_reserved_local_subexpr_1;
    }

    static constexpr bool ValueIsOk(
        bool emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericHasFieldView view_;
  };
  EmbossReservedVirtualXHasYView x_has_y() const;
  ::emboss::support::Maybe<bool> has_x_has_y() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericHasFieldView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.z();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int32_t, ::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(3LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Maximum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)), emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericHasFieldView view_;
  };
  EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericHasFieldView;
};
using HasFieldView =
    GenericHasFieldView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using HasFieldWriter =
    GenericHasFieldView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericHasFieldView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericHasFieldView<
    GenericHasFieldView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericHasFieldView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeHasFieldView( T &&emboss_reserved_local_arg) {
  return GenericHasFieldView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericHasFieldView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeHasFieldView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericHasFieldView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericHasFieldView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedHasFieldView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericHasFieldView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}





namespace VirtualUnconditionallyUsesConditional {

}  // namespace VirtualUnconditionallyUsesConditional


template <class View>
struct EmbossReservedInternalIsGenericVirtualUnconditionallyUsesConditionalView;

template <class Storage>
class GenericVirtualUnconditionallyUsesConditionalView final {
 public:
  GenericVirtualUnconditionallyUsesConditionalView() : backing_() {}
  explicit GenericVirtualUnconditionallyUsesConditionalView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericVirtualUnconditionallyUsesConditionalView(
      const GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericVirtualUnconditionallyUsesConditionalView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericVirtualUnconditionallyUsesConditionalView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericVirtualUnconditionallyUsesConditionalView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericVirtualUnconditionallyUsesConditionalView<Storage> &operator=(
      const GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Equal</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((x().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !xc().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_nor_xc().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  bool Equals(
      GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;



    if (!has_xc().Known()) return false;
    if (!emboss_reserved_local_other.has_xc().Known()) return false;

    if (emboss_reserved_local_other.has_xc().ValueOrDefault() &&
        !has_xc().ValueOrDefault())
      return false;
    if (has_xc().ValueOrDefault() &&
        !emboss_reserved_local_other.has_xc().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_xc().ValueOrDefault() &&
        has_xc().ValueOrDefault() &&
        !xc().Equals(emboss_reserved_local_other.xc()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;



    if (emboss_reserved_local_other.has_xc().ValueOr(false) &&
        !has_xc().ValueOr(false))
      return false;
    if (has_xc().ValueOr(false) &&
        !emboss_reserved_local_other.has_xc().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_xc().ValueOr(false) &&
        has_xc().ValueOr(false) &&
        !xc().UncheckedEquals(emboss_reserved_local_other.xc()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericVirtualUnconditionallyUsesConditionalView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "xc") {
        if (!xc().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_xc().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          xc().IsAggregate() || xc().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("xc: ");
        xc().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !xc().IsAggregate() && !xc().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# xc: UNREADABLE\n");
      }
    }

    if (has_x_nor_xc().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_nor_xc().IsAggregate() || x_nor_xc().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# x_nor_xc: ");
        x_nor_xc().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_nor_xc: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

 xc() const;
  ::emboss::support::Maybe<bool> has_xc() const;

 public:
  class EmbossReservedVirtualXNorXcView final {
   public:
    using ValueType = bool;

    explicit EmbossReservedVirtualXNorXcView(
        const GenericVirtualUnconditionallyUsesConditionalView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXNorXcView() = delete;
    EmbossReservedVirtualXNorXcView(const EmbossReservedVirtualXNorXcView &) = default;
    EmbossReservedVirtualXNorXcView(EmbossReservedVirtualXNorXcView &&) = default;
    EmbossReservedVirtualXNorXcView &operator=(const EmbossReservedVirtualXNorXcView &) =
        default;
    EmbossReservedVirtualXNorXcView &operator=(EmbossReservedVirtualXNorXcView &&) =
        default;
    ~EmbossReservedVirtualXNorXcView() = default;

    bool Read() const {
      EMBOSS_CHECK(view_.has_x_nor_xc().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    bool UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteBooleanViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ bool> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Equal</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_4 = view_.xc();
      const auto emboss_reserved_local_subexpr_5 = (emboss_reserved_local_subexpr_4.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_4.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_6 = ::emboss::support::Equal</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_5, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_7 = ::emboss::support::And</**/bool, bool, bool, bool>(emboss_reserved_local_subexpr_3, emboss_reserved_local_subexpr_6);

      return emboss_reserved_local_subexpr_7;
    }

    static constexpr bool ValueIsOk(
        bool emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericVirtualUnconditionallyUsesConditionalView view_;
  };
  EmbossReservedVirtualXNorXcView x_nor_xc() const;
  ::emboss::support::Maybe<bool> has_x_nor_xc() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericVirtualUnconditionallyUsesConditionalView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Equal</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int32_t, ::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Maximum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)), emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericVirtualUnconditionallyUsesConditionalView view_;
  };
  EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericVirtualUnconditionallyUsesConditionalView;
};
using VirtualUnconditionallyUsesConditionalView =
    GenericVirtualUnconditionallyUsesConditionalView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using VirtualUnconditionallyUsesConditionalWriter =
    GenericVirtualUnconditionallyUsesConditionalView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericVirtualUnconditionallyUsesConditionalView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericVirtualUnconditionallyUsesConditionalView<
    GenericVirtualUnconditionallyUsesConditionalView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericVirtualUnconditionallyUsesConditionalView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeVirtualUnconditionallyUsesConditionalView( T &&emboss_reserved_local_arg) {
  return GenericVirtualUnconditionallyUsesConditionalView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericVirtualUnconditionallyUsesConditionalView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeVirtualUnconditionallyUsesConditionalView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericVirtualUnconditionallyUsesConditionalView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericVirtualUnconditionallyUsesConditionalView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedVirtualUnconditionallyUsesConditionalView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericVirtualUnconditionallyUsesConditionalView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace UsesSize {




namespace R {

}  // namespace R


template <class View>
struct EmbossReservedInternalIsGenericRView;

template <class Storage>
class GenericRView final {
 public:
  GenericRView() : backing_() {}
  explicit GenericRView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericRView(
      const GenericRView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericRView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericRView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericRView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericRView<Storage> &operator=(
      const GenericRView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !q().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBits().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !q_plus_bit_size().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBits().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBits().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericRView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_q().Known()) return false;
    if (!emboss_reserved_local_other.has_q().Known()) return false;

    if (emboss_reserved_local_other.has_q().ValueOrDefault() &&
        !has_q().ValueOrDefault())
      return false;
    if (has_q().ValueOrDefault() &&
        !emboss_reserved_local_other.has_q().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_q().ValueOrDefault() &&
        has_q().ValueOrDefault() &&
        !q().Equals(emboss_reserved_local_other.q()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericRView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_q().ValueOr(false) &&
        !has_q().ValueOr(false))
      return false;
    if (has_q().ValueOr(false) &&
        !emboss_reserved_local_other.has_q().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_q().ValueOr(false) &&
        has_q().ValueOr(false) &&
        !q().UncheckedEquals(emboss_reserved_local_other.q()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericRView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericRView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericRView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "q") {
        if (!q().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_q().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          q().IsAggregate() || q().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("q: ");
        q().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !q().IsAggregate() && !q().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# q: UNREADABLE\n");
      }
    }

    if (has_q_plus_bit_size().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          q_plus_bit_size().IsAggregate() || q_plus_bit_size().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# q_plus_bit_size: ");
        q_plus_bit_size().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# q_plus_bit_size: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 q() const;
  ::emboss::support::Maybe<bool> has_q() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualQPlusBitSizeView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualQPlusBitSizeView(
        const GenericRView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualQPlusBitSizeView() = delete;
    EmbossReservedVirtualQPlusBitSizeView(const EmbossReservedVirtualQPlusBitSizeView &) = default;
    EmbossReservedVirtualQPlusBitSizeView(EmbossReservedVirtualQPlusBitSizeView &&) = default;
    EmbossReservedVirtualQPlusBitSizeView &operator=(const EmbossReservedVirtualQPlusBitSizeView &) =
        default;
    EmbossReservedVirtualQPlusBitSizeView &operator=(EmbossReservedVirtualQPlusBitSizeView &&) =
        default;
    ~EmbossReservedVirtualQPlusBitSizeView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_q_plus_bit_size().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.q();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericRView view_;
  };
  EmbossReservedVirtualQPlusBitSizeView q_plus_bit_size() const;
  ::emboss::support::Maybe<bool> has_q_plus_bit_size() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericRView;
};
using RView =
    GenericRView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using RWriter =
    GenericRView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericRView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericRView<
    GenericRView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericRView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeRView( T &&emboss_reserved_local_arg) {
  return GenericRView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericRView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeRView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericRView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericRView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedRView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericRView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

}  // namespace UsesSize


template <class View>
struct EmbossReservedInternalIsGenericUsesSizeView;

template <class Storage>
class GenericUsesSizeView final {
 public:
  GenericUsesSizeView() : backing_() {}
  explicit GenericUsesSizeView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericUsesSizeView(
      const GenericUsesSizeView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericUsesSizeView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericUsesSizeView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericUsesSizeView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericUsesSizeView<Storage> &operator=(
      const GenericUsesSizeView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !r().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !r_q_plus_byte_size().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericUsesSizeView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_r().Known()) return false;
    if (!emboss_reserved_local_other.has_r().Known()) return false;

    if (emboss_reserved_local_other.has_r().ValueOrDefault() &&
        !has_r().ValueOrDefault())
      return false;
    if (has_r().ValueOrDefault() &&
        !emboss_reserved_local_other.has_r().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_r().ValueOrDefault() &&
        has_r().ValueOrDefault() &&
        !r().Equals(emboss_reserved_local_other.r()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericUsesSizeView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_r().ValueOr(false) &&
        !has_r().ValueOr(false))
      return false;
    if (has_r().ValueOr(false) &&
        !emboss_reserved_local_other.has_r().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_r().ValueOr(false) &&
        has_r().ValueOr(false) &&
        !r().UncheckedEquals(emboss_reserved_local_other.r()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericUsesSizeView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericUsesSizeView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericUsesSizeView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "r") {
        if (!r().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_r().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          r().IsAggregate() || r().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("r: ");
        r().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !r().IsAggregate() && !r().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# r: UNREADABLE\n");
      }
    }

    if (has_r_q_plus_byte_size().ValueOr(false) &&
        emboss_reserved_local_field_options.comments()) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          r_q_plus_byte_size().IsAggregate() || r_q_plus_byte_size().Ok()) {
        emboss_reserved_local_stream->Write(
            emboss_reserved_local_field_options.current_indent());
        emboss_reserved_local_stream->Write("# r_q_plus_byte_size: ");
        r_q_plus_byte_size().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_stream->Write("\n");
      } else {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# r_q_plus_byte_size: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::test::UsesSize::GenericRView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 r() const;
  ::emboss::support::Maybe<bool> has_r() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedVirtualRQPlusByteSizeView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualRQPlusByteSizeView(
        const GenericUsesSizeView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualRQPlusByteSizeView() = delete;
    EmbossReservedVirtualRQPlusByteSizeView(const EmbossReservedVirtualRQPlusByteSizeView &) = default;
    EmbossReservedVirtualRQPlusByteSizeView(EmbossReservedVirtualRQPlusByteSizeView &&) = default;
    EmbossReservedVirtualRQPlusByteSizeView &operator=(const EmbossReservedVirtualRQPlusByteSizeView &) =
        default;
    EmbossReservedVirtualRQPlusByteSizeView &operator=(EmbossReservedVirtualRQPlusByteSizeView &&) =
        default;
    ~EmbossReservedVirtualRQPlusByteSizeView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_r_q_plus_byte_size().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.r().q();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericUsesSizeView view_;
  };
  EmbossReservedVirtualRQPlusByteSizeView r_q_plus_byte_size() const;
  ::emboss::support::Maybe<bool> has_r_q_plus_byte_size() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericUsesSizeView;
};
using UsesSizeView =
    GenericUsesSizeView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using UsesSizeWriter =
    GenericUsesSizeView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericUsesSizeView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericUsesSizeView<
    GenericUsesSizeView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericUsesSizeView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeUsesSizeView( T &&emboss_reserved_local_arg) {
  return GenericUsesSizeView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericUsesSizeView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeUsesSizeView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericUsesSizeView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericUsesSizeView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedUsesSizeView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericUsesSizeView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace UsesExternalSize {

}  // namespace UsesExternalSize


template <class View>
struct EmbossReservedInternalIsGenericUsesExternalSizeView;

template <class Storage>
class GenericUsesExternalSizeView final {
 public:
  GenericUsesExternalSizeView() : backing_() {}
  explicit GenericUsesExternalSizeView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericUsesExternalSizeView(
      const GenericUsesExternalSizeView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericUsesExternalSizeView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericUsesExternalSizeView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericUsesExternalSizeView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericUsesExternalSizeView<Storage> &operator=(
      const GenericUsesExternalSizeView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !y().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericUsesExternalSizeView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;



    if (!has_y().Known()) return false;
    if (!emboss_reserved_local_other.has_y().Known()) return false;

    if (emboss_reserved_local_other.has_y().ValueOrDefault() &&
        !has_y().ValueOrDefault())
      return false;
    if (has_y().ValueOrDefault() &&
        !emboss_reserved_local_other.has_y().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_y().ValueOrDefault() &&
        has_y().ValueOrDefault() &&
        !y().Equals(emboss_reserved_local_other.y()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericUsesExternalSizeView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;



    if (emboss_reserved_local_other.has_y().ValueOr(false) &&
        !has_y().ValueOr(false))
      return false;
    if (has_y().ValueOr(false) &&
        !emboss_reserved_local_other.has_y().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_y().ValueOr(false) &&
        has_y().ValueOr(false) &&
        !y().UncheckedEquals(emboss_reserved_local_other.y()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericUsesExternalSizeView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericUsesExternalSizeView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericUsesExternalSizeView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "y") {
        if (!y().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_y().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          y().IsAggregate() || y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("y: ");
        y().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !y().IsAggregate() && !y().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# y: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 0>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  typename ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 4>>

 y() const;
  ::emboss::support::Maybe<bool> has_y() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericUsesExternalSizeView;
};
using UsesExternalSizeView =
    GenericUsesExternalSizeView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using UsesExternalSizeWriter =
    GenericUsesExternalSizeView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericUsesExternalSizeView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericUsesExternalSizeView<
    GenericUsesExternalSizeView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericUsesExternalSizeView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeUsesExternalSizeView( T &&emboss_reserved_local_arg) {
  return GenericUsesExternalSizeView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericUsesExternalSizeView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeUsesExternalSizeView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericUsesExternalSizeView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericUsesExternalSizeView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedUsesExternalSizeView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericUsesExternalSizeView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}








namespace ImplicitWriteBack {

}  // namespace ImplicitWriteBack


template <class View>
struct EmbossReservedInternalIsGenericImplicitWriteBackView;

template <class Storage>
class GenericImplicitWriteBackView final {
 public:
  GenericImplicitWriteBackView() : backing_() {}
  explicit GenericImplicitWriteBackView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericImplicitWriteBackView(
      const GenericImplicitWriteBackView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericImplicitWriteBackView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericImplicitWriteBackView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericImplicitWriteBackView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericImplicitWriteBackView<Storage> &operator=(
      const GenericImplicitWriteBackView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_plus_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !ten_plus_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !x_minus_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !ten_minus_x().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !ten_minus_x_plus_ten().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !IntrinsicSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MaxSizeInBytes().Ok()) return false;
    }


    {
      const auto emboss_reserved_local_field_present = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_local_field_present.Known()) return false;
      if (emboss_reserved_local_field_present.ValueOrDefault() && !MinSizeInBytes().Ok()) return false;
    }



    return true;
  }
  Storage BackingStorage() const { return backing_; }
  bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  bool Equals(
      GenericImplicitWriteBackView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_x().Known()) return false;
    if (!emboss_reserved_local_other.has_x().Known()) return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        !has_x().ValueOrDefault())
      return false;
    if (has_x().ValueOrDefault() &&
        !emboss_reserved_local_other.has_x().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_x().ValueOrDefault() &&
        has_x().ValueOrDefault() &&
        !x().Equals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  bool UncheckedEquals(
      GenericImplicitWriteBackView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        !has_x().ValueOr(false))
      return false;
    if (has_x().ValueOr(false) &&
        !emboss_reserved_local_other.has_x().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_x().ValueOr(false) &&
        has_x().ValueOr(false) &&
        !x().UncheckedEquals(emboss_reserved_local_other.x()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericImplicitWriteBackView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericImplicitWriteBackView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  bool TryToCopyFrom(
      GenericImplicitWriteBackView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "x") {
        if (!x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "x_plus_ten") {
        if (!x_plus_ten().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "ten_plus_x") {
        if (!ten_plus_x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "x_minus_ten") {
        if (!x_minus_ten().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "ten_minus_x") {
        if (!ten_minus_x().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "ten_minus_x_plus_ten") {
        if (!ten_minus_x_plus_ten().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x().IsAggregate() || x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x: ");
        x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x().IsAggregate() && !x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x: UNREADABLE\n");
      }
    }

    if (has_x_plus_ten().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_plus_ten().IsAggregate() || x_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x_plus_ten: ");
        x_plus_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x_plus_ten().IsAggregate() && !x_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_plus_ten: UNREADABLE\n");
      }
    }

    if (has_ten_plus_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          ten_plus_x().IsAggregate() || ten_plus_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("ten_plus_x: ");
        ten_plus_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !ten_plus_x().IsAggregate() && !ten_plus_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# ten_plus_x: UNREADABLE\n");
      }
    }

    if (has_x_minus_ten().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          x_minus_ten().IsAggregate() || x_minus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("x_minus_ten: ");
        x_minus_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !x_minus_ten().IsAggregate() && !x_minus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# x_minus_ten: UNREADABLE\n");
      }
    }

    if (has_ten_minus_x().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          ten_minus_x().IsAggregate() || ten_minus_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("ten_minus_x: ");
        ten_minus_x().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !ten_minus_x().IsAggregate() && !ten_minus_x().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# ten_minus_x: UNREADABLE\n");
      }
    }

    if (has_ten_minus_x_plus_ten().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          ten_minus_x_plus_ten().IsAggregate() || ten_minus_x_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("ten_minus_x_plus_ten: ");
        ten_minus_x_plus_ten().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !ten_minus_x_plus_ten().IsAggregate() && !ten_minus_x_plus_ten().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# ten_minus_x_plus_ten: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  static constexpr bool IsAggregate() { return true; }

 public:
  typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 x() const;
  ::emboss::support::Maybe<bool> has_x() const;

 public:
  class EmbossReservedVirtualXPlusTenView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualXPlusTenView(
        const GenericImplicitWriteBackView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXPlusTenView() = delete;
    EmbossReservedVirtualXPlusTenView(const EmbossReservedVirtualXPlusTenView &) = default;
    EmbossReservedVirtualXPlusTenView(EmbossReservedVirtualXPlusTenView &&) = default;
    EmbossReservedVirtualXPlusTenView &operator=(const EmbossReservedVirtualXPlusTenView &) =
        default;
    EmbossReservedVirtualXPlusTenView &operator=(EmbossReservedVirtualXPlusTenView &&) =
        default;
    ~EmbossReservedVirtualXPlusTenView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_x_plus_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericImplicitWriteBackView view_;
  };
  EmbossReservedVirtualXPlusTenView x_plus_ten() const;
  ::emboss::support::Maybe<bool> has_x_plus_ten() const;

 public:
  class EmbossReservedVirtualTenPlusXView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualTenPlusXView(
        const GenericImplicitWriteBackView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTenPlusXView() = delete;
    EmbossReservedVirtualTenPlusXView(const EmbossReservedVirtualTenPlusXView &) = default;
    EmbossReservedVirtualTenPlusXView(EmbossReservedVirtualTenPlusXView &&) = default;
    EmbossReservedVirtualTenPlusXView &operator=(const EmbossReservedVirtualTenPlusXView &) =
        default;
    EmbossReservedVirtualTenPlusXView &operator=(EmbossReservedVirtualTenPlusXView &&) =
        default;
    ~EmbossReservedVirtualTenPlusXView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_ten_plus_x().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), emboss_reserved_local_subexpr_2);

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericImplicitWriteBackView view_;
  };
  EmbossReservedVirtualTenPlusXView ten_plus_x() const;
  ::emboss::support::Maybe<bool> has_ten_plus_x() const;

 public:
  class EmbossReservedVirtualXMinusTenView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualXMinusTenView(
        const GenericImplicitWriteBackView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualXMinusTenView() = delete;
    EmbossReservedVirtualXMinusTenView(const EmbossReservedVirtualXMinusTenView &) = default;
    EmbossReservedVirtualXMinusTenView(EmbossReservedVirtualXMinusTenView &&) = default;
    EmbossReservedVirtualXMinusTenView &operator=(const EmbossReservedVirtualXMinusTenView &) =
        default;
    EmbossReservedVirtualXMinusTenView &operator=(EmbossReservedVirtualXMinusTenView &&) =
        default;
    ~EmbossReservedVirtualXMinusTenView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_x_minus_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericImplicitWriteBackView view_;
  };
  EmbossReservedVirtualXMinusTenView x_minus_ten() const;
  ::emboss::support::Maybe<bool> has_x_minus_ten() const;

 public:
  class EmbossReservedVirtualTenMinusXView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualTenMinusXView(
        const GenericImplicitWriteBackView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTenMinusXView() = delete;
    EmbossReservedVirtualTenMinusXView(const EmbossReservedVirtualTenMinusXView &) = default;
    EmbossReservedVirtualTenMinusXView(EmbossReservedVirtualTenMinusXView &&) = default;
    EmbossReservedVirtualTenMinusXView &operator=(const EmbossReservedVirtualTenMinusXView &) =
        default;
    EmbossReservedVirtualTenMinusXView &operator=(EmbossReservedVirtualTenMinusXView &&) =
        default;
    ~EmbossReservedVirtualTenMinusXView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_ten_minus_x().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), emboss_reserved_local_subexpr_2);

      return emboss_reserved_local_subexpr_3;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericImplicitWriteBackView view_;
  };
  EmbossReservedVirtualTenMinusXView ten_minus_x() const;
  ::emboss::support::Maybe<bool> has_ten_minus_x() const;

 public:
  class EmbossReservedVirtualTenMinusXPlusTenView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualTenMinusXPlusTenView(
        const GenericImplicitWriteBackView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualTenMinusXPlusTenView() = delete;
    EmbossReservedVirtualTenMinusXPlusTenView(const EmbossReservedVirtualTenMinusXPlusTenView &) = default;
    EmbossReservedVirtualTenMinusXPlusTenView(EmbossReservedVirtualTenMinusXPlusTenView &&) = default;
    EmbossReservedVirtualTenMinusXPlusTenView &operator=(const EmbossReservedVirtualTenMinusXPlusTenView &) =
        default;
    EmbossReservedVirtualTenMinusXPlusTenView &operator=(EmbossReservedVirtualTenMinusXPlusTenView &&) =
        default;
    ~EmbossReservedVirtualTenMinusXPlusTenView() = default;

    ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_ten_minus_x_plus_ten().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }

    bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL))));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.x().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.x().UncheckedWrite((::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL))))).ValueOrDefault());
    }
    bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL))));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.x().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.x();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)), emboss_reserved_local_subexpr_2);
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));

      return emboss_reserved_local_subexpr_4;
    }

    static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericImplicitWriteBackView view_;
  };
  EmbossReservedVirtualTenMinusXPlusTenView ten_minus_x_plus_ten() const;
  ::emboss::support::Maybe<bool> has_ten_minus_x_plus_ten() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    static constexpr ::std::int32_t Read();
    static constexpr ::std::int32_t UncheckedRead();
    static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    static constexpr bool IsAggregate() { return false; }
  };

  static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericImplicitWriteBackView;
};
using ImplicitWriteBackView =
    GenericImplicitWriteBackView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using ImplicitWriteBackWriter =
    GenericImplicitWriteBackView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericImplicitWriteBackView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericImplicitWriteBackView<
    GenericImplicitWriteBackView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
inline GenericImplicitWriteBackView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeImplicitWriteBackView( T &&emboss_reserved_local_arg) {
  return GenericImplicitWriteBackView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
inline GenericImplicitWriteBackView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeImplicitWriteBackView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericImplicitWriteBackView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
inline GenericImplicitWriteBackView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedImplicitWriteBackView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericImplicitWriteBackView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

namespace StructureWithConstants {

}  // namespace StructureWithConstants


namespace StructureWithConstants {
inline constexpr ::std::int32_t ten() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualTenView::Read() {
  return StructureWithConstants::ten();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualTenView::UncheckedRead() {
  return StructureWithConstants::ten();
}

namespace StructureWithConstants {
inline constexpr ::std::int32_t twenty() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(20LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualTwentyView::Read() {
  return StructureWithConstants::twenty();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualTwentyView::UncheckedRead() {
  return StructureWithConstants::twenty();
}

namespace StructureWithConstants {
inline constexpr ::std::uint32_t four_billion() {
  return ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(4000000000ULL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::uint32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualFourBillionView::Read() {
  return StructureWithConstants::four_billion();
}

template <class Storage>
inline constexpr ::std::uint32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualFourBillionView::UncheckedRead() {
  return StructureWithConstants::four_billion();
}

namespace StructureWithConstants {
inline constexpr ::std::int64_t ten_billion() {
  return ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(10000000000LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualTenBillionView::Read() {
  return StructureWithConstants::ten_billion();
}

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualTenBillionView::UncheckedRead() {
  return StructureWithConstants::ten_billion();
}

namespace StructureWithConstants {
inline constexpr ::std::int64_t minus_ten_billion() {
  return ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(-10000000000LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualMinusTenBillionView::Read() {
  return StructureWithConstants::minus_ten_billion();
}

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualMinusTenBillionView::UncheckedRead() {
  return StructureWithConstants::minus_ten_billion();
}

template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithConstantsView<Storage>::value()
    const {

  if ( has_value().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConstantsView<Storage>::has_value() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConstantsView<Storage>::has_alias_of_value() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConstantsView<Storage>::has_alias_of_alias_of_value() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithConstants {
inline constexpr ::std::int32_t alias_of_ten() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualAliasOfTenView::Read() {
  return StructureWithConstants::alias_of_ten();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualAliasOfTenView::UncheckedRead() {
  return StructureWithConstants::alias_of_ten();
}

namespace StructureWithConstants {
inline constexpr ::std::int32_t alias_of_alias_of_ten() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedVirtualAliasOfAliasOfTenView::Read() {
  return StructureWithConstants::alias_of_alias_of_ten();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedVirtualAliasOfAliasOfTenView::UncheckedRead() {
  return StructureWithConstants::alias_of_alias_of_ten();
}

namespace StructureWithConstants {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithConstants::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithConstants::IntrinsicSizeInBytes();
}

namespace StructureWithConstants {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithConstants::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithConstants::MaxSizeInBytes();
}

namespace StructureWithConstants {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithConstants::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConstantsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithConstants::MinSizeInBytes();
}
namespace StructureWithComputedValues {

}  // namespace StructureWithComputedValues


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithComputedValuesView<Storage>::value()
    const {

  if ( has_value().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_value() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualDoubledView
GenericStructureWithComputedValuesView<Storage>::doubled() const {
  return
      typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualDoubledView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_doubled() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualPlusTenView
GenericStructureWithComputedValuesView<Storage>::plus_ten() const {
  return
      typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualPlusTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_plus_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::IntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 GenericStructureWithComputedValuesView<Storage>::value2()
    const {

  if ( has_value2().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::IntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::IntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_value2() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualSignedDoubledView
GenericStructureWithComputedValuesView<Storage>::signed_doubled() const {
  return
      typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualSignedDoubledView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_signed_doubled() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualSignedPlusTenView
GenericStructureWithComputedValuesView<Storage>::signed_plus_ten() const {
  return
      typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualSignedPlusTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_signed_plus_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualProductView
GenericStructureWithComputedValuesView<Storage>::product() const {
  return
      typename GenericStructureWithComputedValuesView<Storage>::EmbossReservedVirtualProductView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithComputedValuesView<Storage>::has_product() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithComputedValues {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace StructureWithComputedValues

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithComputedValues::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithComputedValues::IntrinsicSizeInBytes();
}

namespace StructureWithComputedValues {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace StructureWithComputedValues

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithComputedValues::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithComputedValues::MaxSizeInBytes();
}

namespace StructureWithComputedValues {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace StructureWithComputedValues

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithComputedValues::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithComputedValuesView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithComputedValues::MinSizeInBytes();
}
namespace StructureWithConditionalValue {

}  // namespace StructureWithConditionalValue


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithConditionalValueView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConditionalValueView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithConditionalValueView<Storage>::EmbossReservedVirtualTwoXView
GenericStructureWithConditionalValueView<Storage>::two_x() const {
  return
      typename GenericStructureWithConditionalValueView<Storage>::EmbossReservedVirtualTwoXView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConditionalValueView<Storage>::has_two_x() const {
  return ::emboss::support::LessThan</**/::std::uint32_t, bool, ::std::uint32_t, ::std::uint32_t>((x().Ok()    ? ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::uint32_t>()), ::emboss::support::Maybe</**/::std::uint32_t>(static_cast</**/::std::uint32_t>(2147483648ULL)));
}


template <class Storage>
inline typename GenericStructureWithConditionalValueView<Storage>::EmbossReservedVirtualXPlusOneView
GenericStructureWithConditionalValueView<Storage>::x_plus_one() const {
  return
      typename GenericStructureWithConditionalValueView<Storage>::EmbossReservedVirtualXPlusOneView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithConditionalValueView<Storage>::has_x_plus_one() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithConditionalValue {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConditionalValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithConditionalValue::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithConditionalValue::IntrinsicSizeInBytes();
}

namespace StructureWithConditionalValue {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConditionalValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithConditionalValue::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithConditionalValue::MaxSizeInBytes();
}

namespace StructureWithConditionalValue {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithConditionalValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithConditionalValue::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithConditionalValueView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithConditionalValue::MinSizeInBytes();
}
namespace StructureWithValueInCondition {

}  // namespace StructureWithValueInCondition


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithValueInConditionView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValueInConditionView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithValueInConditionView<Storage>::EmbossReservedVirtualTwoXView
GenericStructureWithValueInConditionView<Storage>::two_x() const {
  return
      typename GenericStructureWithValueInConditionView<Storage>::EmbossReservedVirtualTwoXView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValueInConditionView<Storage>::has_two_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 GenericStructureWithValueInConditionView<Storage>::if_two_x_lt_100()
    const {

  if ( has_if_two_x_lt_100().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValueInConditionView<Storage>::has_if_two_x_lt_100() const {
  return ::emboss::support::LessThan</**/::std::int64_t, bool, ::std::int64_t, ::std::int32_t>((two_x().Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(two_x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
}


template <class Storage>
inline typename GenericStructureWithValueInConditionView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericStructureWithValueInConditionView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericStructureWithValueInConditionView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValueInConditionView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithValueInCondition {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace StructureWithValueInCondition

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValueInConditionView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithValueInCondition::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValueInConditionView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithValueInCondition::MaxSizeInBytes();
}

namespace StructureWithValueInCondition {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithValueInCondition

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValueInConditionView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithValueInCondition::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValueInConditionView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithValueInCondition::MinSizeInBytes();
}
namespace StructureWithValuesInLocation {

}  // namespace StructureWithValuesInLocation


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithValuesInLocationView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValuesInLocationView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithValuesInLocationView<Storage>::EmbossReservedVirtualTwoXView
GenericStructureWithValuesInLocationView<Storage>::two_x() const {
  return
      typename GenericStructureWithValuesInLocationView<Storage>::EmbossReservedVirtualTwoXView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValuesInLocationView<Storage>::has_two_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/2, 0>>, 32>>

 GenericStructureWithValuesInLocationView<Storage>::offset_two_x()
    const {

  if ( has_offset_two_x().ValueOr(false)) {
    const auto emboss_reserved_local_subexpr_1 = two_x();
    const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>());

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = emboss_reserved_local_subexpr_2;
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/2, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<2,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/2, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValuesInLocationView<Storage>::has_offset_two_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

 GenericStructureWithValuesInLocationView<Storage>::size_two_x()
    const {

  if ( has_size_two_x().ValueOr(false)) {
    const auto emboss_reserved_local_subexpr_1 = two_x();
    const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int64_t>());

    auto emboss_reserved_local_size = emboss_reserved_local_subexpr_2;
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValuesInLocationView<Storage>::has_size_two_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithValuesInLocationView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericStructureWithValuesInLocationView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericStructureWithValuesInLocationView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithValuesInLocationView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithValuesInLocation {
inline constexpr ::std::int64_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int64_t>(static_cast</**/::std::int64_t>(8589934594LL)).ValueOrDefault();
}
}  // namespace StructureWithValuesInLocation

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithValuesInLocationView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithValuesInLocation::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int64_t
GenericStructureWithValuesInLocationView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithValuesInLocation::MaxSizeInBytes();
}

namespace StructureWithValuesInLocation {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithValuesInLocation

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValuesInLocationView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithValuesInLocation::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithValuesInLocationView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithValuesInLocation::MinSizeInBytes();
}
namespace StructureWithBoolValue {

}  // namespace StructureWithBoolValue


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithBoolValueView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithBoolValueView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithBoolValueView<Storage>::EmbossReservedVirtualXIsTenView
GenericStructureWithBoolValueView<Storage>::x_is_ten() const {
  return
      typename GenericStructureWithBoolValueView<Storage>::EmbossReservedVirtualXIsTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithBoolValueView<Storage>::has_x_is_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithBoolValue {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBoolValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithBoolValue::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithBoolValue::IntrinsicSizeInBytes();
}

namespace StructureWithBoolValue {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBoolValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithBoolValue::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithBoolValue::MaxSizeInBytes();
}

namespace StructureWithBoolValue {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBoolValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithBoolValue::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBoolValueView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithBoolValue::MinSizeInBytes();
}
namespace StructureWithEnumValue {

}  // namespace StructureWithEnumValue


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithEnumValueView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithEnumValueView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithEnumValueView<Storage>::EmbossReservedVirtualXSizeView
GenericStructureWithEnumValueView<Storage>::x_size() const {
  return
      typename GenericStructureWithEnumValueView<Storage>::EmbossReservedVirtualXSizeView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithEnumValueView<Storage>::has_x_size() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithEnumValue {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithEnumValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithEnumValue::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithEnumValue::IntrinsicSizeInBytes();
}

namespace StructureWithEnumValue {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithEnumValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithEnumValue::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithEnumValue::MaxSizeInBytes();
}

namespace StructureWithEnumValue {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithEnumValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithEnumValue::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithEnumValueView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithEnumValue::MinSizeInBytes();
}
namespace StructureWithBitsWithValue {

}  // namespace StructureWithBitsWithValue


template <class Storage>
inline typename ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericStructureWithBitsWithValueView<Storage>::b()
    const {

  if ( has_b().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithBitsWithValueView<Storage>::has_b() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructureWithBitsWithValueView<Storage>::EmbossReservedVirtualAliasOfBSumView
GenericStructureWithBitsWithValueView<Storage>::alias_of_b_sum() const {
  return
      typename GenericStructureWithBitsWithValueView<Storage>::EmbossReservedVirtualAliasOfBSumView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithBitsWithValueView<Storage>::has_alias_of_b_sum() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureWithBitsWithValueView<Storage>::has_alias_of_b_a() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureWithBitsWithValue {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureWithBitsWithValue::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureWithBitsWithValue::IntrinsicSizeInBytes();
}

namespace StructureWithBitsWithValue {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureWithBitsWithValue::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureWithBitsWithValue::MaxSizeInBytes();
}

namespace StructureWithBitsWithValue {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace StructureWithBitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureWithBitsWithValue::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureWithBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureWithBitsWithValue::MinSizeInBytes();
}
namespace BitsWithValue {

}  // namespace BitsWithValue


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 GenericBitsWithValueView<Storage>::a()
    const {

  if ( has_a().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericBitsWithValueView<Storage>::has_a() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 16>>

 GenericBitsWithValueView<Storage>::b()
    const {

  if ( has_b().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 16>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   16>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 16>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericBitsWithValueView<Storage>::has_b() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericBitsWithValueView<Storage>::EmbossReservedVirtualSumView
GenericBitsWithValueView<Storage>::sum() const {
  return
      typename GenericBitsWithValueView<Storage>::EmbossReservedVirtualSumView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericBitsWithValueView<Storage>::has_sum() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace BitsWithValue {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace BitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return BitsWithValue::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return BitsWithValue::IntrinsicSizeInBits();
}

namespace BitsWithValue {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace BitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return BitsWithValue::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return BitsWithValue::MaxSizeInBits();
}

namespace BitsWithValue {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace BitsWithValue

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return BitsWithValue::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitsWithValueView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return BitsWithValue::MinSizeInBits();
}
namespace StructureUsingForeignConstants {

}  // namespace StructureUsingForeignConstants


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 10>>, 32>>

 GenericStructureUsingForeignConstantsView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 10>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   10>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<32, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 10>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructureUsingForeignConstantsView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructureUsingForeignConstants {
inline constexpr ::std::int32_t one_hundred() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)).ValueOrDefault();
}
}  // namespace StructureUsingForeignConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<Storage>::EmbossReservedVirtualOneHundredView::Read() {
  return StructureUsingForeignConstants::one_hundred();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<
    Storage>::EmbossReservedVirtualOneHundredView::UncheckedRead() {
  return StructureUsingForeignConstants::one_hundred();
}

namespace StructureUsingForeignConstants {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(14LL)).ValueOrDefault();
}
}  // namespace StructureUsingForeignConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return StructureUsingForeignConstants::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return StructureUsingForeignConstants::IntrinsicSizeInBytes();
}

namespace StructureUsingForeignConstants {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(14LL)).ValueOrDefault();
}
}  // namespace StructureUsingForeignConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructureUsingForeignConstants::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructureUsingForeignConstants::MaxSizeInBytes();
}

namespace StructureUsingForeignConstants {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(14LL)).ValueOrDefault();
}
}  // namespace StructureUsingForeignConstants

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructureUsingForeignConstants::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructureUsingForeignConstantsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructureUsingForeignConstants::MinSizeInBytes();
}
namespace SubfieldOfAlias {
namespace Header {

}  // namespace Header


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

 GenericHeaderView<Storage>::size()
    const {

  if ( has_size().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHeaderView<Storage>::has_size() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 2>>, 16>>

 GenericHeaderView<Storage>::message_id()
    const {

  if ( has_message_id().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 2>>, 16>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   2>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<16, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 2>>, 16>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHeaderView<Storage>::has_message_id() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace Header {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace Header

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return Header::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return Header::IntrinsicSizeInBytes();
}

namespace Header {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace Header

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return Header::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return Header::MaxSizeInBytes();
}

namespace Header {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace Header

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return Header::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericHeaderView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return Header::MinSizeInBytes();
}

}  // namespace SubfieldOfAlias


template <class Storage>
inline typename ::emboss::test::SubfieldOfAlias::GenericHeaderView<typename Storage::template OffsetStorageType</**/0, 0>>

 GenericSubfieldOfAliasView<Storage>::header()
    const {

  if ( has_header().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::SubfieldOfAlias::GenericHeaderView<typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::SubfieldOfAlias::GenericHeaderView<typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericSubfieldOfAliasView<Storage>::has_header() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericSubfieldOfAliasView<Storage>::has_h() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericSubfieldOfAliasView<Storage>::has_size() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace SubfieldOfAlias {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace SubfieldOfAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return SubfieldOfAlias::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return SubfieldOfAlias::IntrinsicSizeInBytes();
}

namespace SubfieldOfAlias {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace SubfieldOfAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return SubfieldOfAlias::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return SubfieldOfAlias::MaxSizeInBytes();
}

namespace SubfieldOfAlias {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL)).ValueOrDefault();
}
}  // namespace SubfieldOfAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return SubfieldOfAlias::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericSubfieldOfAliasView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return SubfieldOfAlias::MinSizeInBytes();
}
namespace RestrictedAlias {

}  // namespace RestrictedAlias


template <class Storage>
inline typename ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

 GenericRestrictedAliasView<Storage>::a_b()
    const {

  if ( has_a_b().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericBitsWithValueView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericRestrictedAliasView<Storage>::has_a_b() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 8>>

 GenericRestrictedAliasView<Storage>::alias_switch()
    const {

  if ( has_alias_switch().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 4>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericRestrictedAliasView<Storage>::has_alias_switch() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericRestrictedAliasView<Storage>::has_a_b_alias() const {
  return ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((alias_switch().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(alias_switch().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
}


namespace RestrictedAlias {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(5LL)).ValueOrDefault();
}
}  // namespace RestrictedAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return RestrictedAlias::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return RestrictedAlias::IntrinsicSizeInBytes();
}

namespace RestrictedAlias {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(5LL)).ValueOrDefault();
}
}  // namespace RestrictedAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return RestrictedAlias::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return RestrictedAlias::MaxSizeInBytes();
}

namespace RestrictedAlias {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(5LL)).ValueOrDefault();
}
}  // namespace RestrictedAlias

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return RestrictedAlias::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRestrictedAliasView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return RestrictedAlias::MinSizeInBytes();
}
namespace HasField {
namespace X {

}  // namespace X


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericXView<Storage>::v()
    const {

  if ( has_v().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericXView<Storage>::has_v() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

 GenericXView<Storage>::y()
    const {

  if ( has_y().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   1>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericXView<Storage>::has_y() const {
  return ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((v().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(v().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
}


template <class Storage>
inline typename GenericXView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericXView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericXView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericXView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace X {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)).ValueOrDefault();
}
}  // namespace X

template <class Storage>
inline constexpr ::std::int32_t
GenericXView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return X::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericXView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return X::MaxSizeInBytes();
}

namespace X {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace X

template <class Storage>
inline constexpr ::std::int32_t
GenericXView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return X::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericXView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return X::MinSizeInBytes();
}

}  // namespace HasField


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericHasFieldView<Storage>::z()
    const {

  if ( has_z().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHasFieldView<Storage>::has_z() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::HasField::GenericXView<typename Storage::template OffsetStorageType</**/0, 1>>

 GenericHasFieldView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::HasField::GenericXView<typename Storage::template OffsetStorageType</**/0, 1>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   1>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::HasField::GenericXView<typename Storage::template OffsetStorageType</**/0, 1>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHasFieldView<Storage>::has_x() const {
  return ::emboss::support::GreaterThan</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((z().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(z().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(10LL)));
}


template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHasFieldView<Storage>::has_y() const {
  return x().has_y();
}


template <class Storage>
inline typename GenericHasFieldView<Storage>::EmbossReservedVirtualXHasYView
GenericHasFieldView<Storage>::x_has_y() const {
  return
      typename GenericHasFieldView<Storage>::EmbossReservedVirtualXHasYView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHasFieldView<Storage>::has_x_has_y() const {
  return has_x();
}


template <class Storage>
inline typename GenericHasFieldView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericHasFieldView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericHasFieldView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericHasFieldView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace HasField {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(3LL)).ValueOrDefault();
}
}  // namespace HasField

template <class Storage>
inline constexpr ::std::int32_t
GenericHasFieldView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return HasField::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericHasFieldView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return HasField::MaxSizeInBytes();
}

namespace HasField {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace HasField

template <class Storage>
inline constexpr ::std::int32_t
GenericHasFieldView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return HasField::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericHasFieldView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return HasField::MinSizeInBytes();
}
namespace VirtualUnconditionallyUsesConditional {

}  // namespace VirtualUnconditionallyUsesConditional


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericVirtualUnconditionallyUsesConditionalView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericVirtualUnconditionallyUsesConditionalView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

 GenericVirtualUnconditionallyUsesConditionalView<Storage>::xc()
    const {

  if ( has_xc().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   1>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericVirtualUnconditionallyUsesConditionalView<Storage>::has_xc() const {
  return ::emboss::support::Equal</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>((x().Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(x().UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>()), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
}


template <class Storage>
inline typename GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedVirtualXNorXcView
GenericVirtualUnconditionallyUsesConditionalView<Storage>::x_nor_xc() const {
  return
      typename GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedVirtualXNorXcView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericVirtualUnconditionallyUsesConditionalView<Storage>::has_x_nor_xc() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericVirtualUnconditionallyUsesConditionalView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericVirtualUnconditionallyUsesConditionalView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace VirtualUnconditionallyUsesConditional {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)).ValueOrDefault();
}
}  // namespace VirtualUnconditionallyUsesConditional

template <class Storage>
inline constexpr ::std::int32_t
GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return VirtualUnconditionallyUsesConditional::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericVirtualUnconditionallyUsesConditionalView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return VirtualUnconditionallyUsesConditional::MaxSizeInBytes();
}

namespace VirtualUnconditionallyUsesConditional {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace VirtualUnconditionallyUsesConditional

template <class Storage>
inline constexpr ::std::int32_t
GenericVirtualUnconditionallyUsesConditionalView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return VirtualUnconditionallyUsesConditional::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericVirtualUnconditionallyUsesConditionalView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return VirtualUnconditionallyUsesConditional::MinSizeInBytes();
}
namespace UsesSize {
namespace R {

}  // namespace R


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 GenericRView<Storage>::q()
    const {

  if ( has_q().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericRView<Storage>::has_q() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace R {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace R

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return R::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return R::IntrinsicSizeInBits();
}

template <class Storage>
inline typename GenericRView<Storage>::EmbossReservedVirtualQPlusBitSizeView
GenericRView<Storage>::q_plus_bit_size() const {
  return
      typename GenericRView<Storage>::EmbossReservedVirtualQPlusBitSizeView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericRView<Storage>::has_q_plus_bit_size() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace R {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace R

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return R::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return R::MaxSizeInBits();
}

namespace R {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace R

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return R::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericRView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return R::MinSizeInBits();
}

}  // namespace UsesSize


template <class Storage>
inline typename ::emboss::test::UsesSize::GenericRView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericUsesSizeView<Storage>::r()
    const {

  if ( has_r().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::UsesSize::GenericRView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::UsesSize::GenericRView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUsesSizeView<Storage>::has_r() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace UsesSize {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace UsesSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return UsesSize::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return UsesSize::IntrinsicSizeInBytes();
}

template <class Storage>
inline typename GenericUsesSizeView<Storage>::EmbossReservedVirtualRQPlusByteSizeView
GenericUsesSizeView<Storage>::r_q_plus_byte_size() const {
  return
      typename GenericUsesSizeView<Storage>::EmbossReservedVirtualRQPlusByteSizeView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUsesSizeView<Storage>::has_r_q_plus_byte_size() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace UsesSize {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace UsesSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return UsesSize::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return UsesSize::MaxSizeInBytes();
}

namespace UsesSize {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace UsesSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return UsesSize::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesSizeView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return UsesSize::MinSizeInBytes();
}
namespace UsesExternalSize {

}  // namespace UsesExternalSize


template <class Storage>
inline typename ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 0>>

 GenericUsesExternalSizeView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUsesExternalSizeView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 4>>

 GenericUsesExternalSizeView<Storage>::y()
    const {

  if ( has_y().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 4>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericStructureWithConstantsView<typename Storage::template OffsetStorageType</**/0, 4>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericUsesExternalSizeView<Storage>::has_y() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace UsesExternalSize {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace UsesExternalSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return UsesExternalSize::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return UsesExternalSize::IntrinsicSizeInBytes();
}

namespace UsesExternalSize {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace UsesExternalSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return UsesExternalSize::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return UsesExternalSize::MaxSizeInBytes();
}

namespace UsesExternalSize {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace UsesExternalSize

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return UsesExternalSize::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericUsesExternalSizeView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return UsesExternalSize::MinSizeInBytes();
}
namespace ImplicitWriteBack {

}  // namespace ImplicitWriteBack


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericImplicitWriteBackView<Storage>::x()
    const {

  if ( has_x().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualXPlusTenView
GenericImplicitWriteBackView<Storage>::x_plus_ten() const {
  return
      typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualXPlusTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_x_plus_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenPlusXView
GenericImplicitWriteBackView<Storage>::ten_plus_x() const {
  return
      typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenPlusXView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_ten_plus_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualXMinusTenView
GenericImplicitWriteBackView<Storage>::x_minus_ten() const {
  return
      typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualXMinusTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_x_minus_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenMinusXView
GenericImplicitWriteBackView<Storage>::ten_minus_x() const {
  return
      typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenMinusXView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_ten_minus_x() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenMinusXPlusTenView
GenericImplicitWriteBackView<Storage>::ten_minus_x_plus_ten() const {
  return
      typename GenericImplicitWriteBackView<Storage>::EmbossReservedVirtualTenMinusXPlusTenView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericImplicitWriteBackView<Storage>::has_ten_minus_x_plus_ten() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace ImplicitWriteBack {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace ImplicitWriteBack

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return ImplicitWriteBack::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return ImplicitWriteBack::IntrinsicSizeInBytes();
}

namespace ImplicitWriteBack {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace ImplicitWriteBack

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return ImplicitWriteBack::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return ImplicitWriteBack::MaxSizeInBytes();
}

namespace ImplicitWriteBack {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)).ValueOrDefault();
}
}  // namespace ImplicitWriteBack

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return ImplicitWriteBack::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericImplicitWriteBackView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return ImplicitWriteBack::MinSizeInBytes();
}



}  // namespace test



}  // namespace emboss



/* NOLINTEND */

#endif  // TESTDATA_VIRTUAL_FIELD_EMB_H_

