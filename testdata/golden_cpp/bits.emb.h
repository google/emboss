/**
 * Generated by the Emboss compiler.  DO NOT EDIT!
 */
#ifndef TESTDATA_BITS_EMB_H_
#define TESTDATA_BITS_EMB_H_
#include <stdint.h>
#include <string.h>

#include <algorithm>
#include <type_traits>
#include <utility>

#include "runtime/cpp/emboss_cpp_util.h"

#include "runtime/cpp/emboss_prelude.h"

#include "runtime/cpp/emboss_enum_view.h"

#include "runtime/cpp/emboss_text_util.h"



/* NOLINTBEGIN */
namespace emboss {
namespace test {
namespace OneByte {

}  // namespace OneByte


template <class Storage>
class GenericOneByteView;

namespace FourByte {
namespace TwoByteWithGaps {

}  // namespace TwoByteWithGaps


template <class Storage>
class GenericTwoByteWithGapsView;


}  // namespace FourByte


template <class Storage>
class GenericFourByteView;

namespace ArrayInBits {

}  // namespace ArrayInBits


template <class Storage>
class GenericArrayInBitsView;

namespace ArrayInBitsInStruct {

}  // namespace ArrayInBitsInStruct


template <class Storage>
class GenericArrayInBitsInStructView;

namespace StructOfBits {

}  // namespace StructOfBits


template <class Storage>
class GenericStructOfBitsView;

namespace BitArray {

}  // namespace BitArray


template <class Storage>
class GenericBitArrayView;









namespace OneByte {

}  // namespace OneByte


template <class View>
struct EmbossReservedInternalIsGenericOneByteView;

template <class Storage>
class GenericOneByteView final {
 public:
  GenericOneByteView() : backing_() {}
  explicit GenericOneByteView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericOneByteView(
      const GenericOneByteView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericOneByteView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericOneByteView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericOneByteView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericOneByteView<Storage> &operator=(
      const GenericOneByteView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!high_bit().Ok()) return false;
        if (!less_high_bit().Ok()) return false;
        if (!mid_nibble().Ok()) return false;
        if (!less_low_bit().Ok()) return false;
        if (!low_bit().Ok()) return false;
        if (!IntrinsicSizeInBits().Ok()) return false;
        if (!MaxSizeInBits().Ok()) return false;
        if (!MinSizeInBits().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericOneByteView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_high_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_high_bit().Known()) return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOrDefault() &&
        !has_high_bit().ValueOrDefault())
      return false;
    if (has_high_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_high_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOrDefault() &&
        has_high_bit().ValueOrDefault() &&
        !high_bit().Equals(emboss_reserved_local_other.high_bit()))
      return false;



    if (!has_less_high_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_less_high_bit().Known()) return false;

    if (emboss_reserved_local_other.has_less_high_bit().ValueOrDefault() &&
        !has_less_high_bit().ValueOrDefault())
      return false;
    if (has_less_high_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_less_high_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_less_high_bit().ValueOrDefault() &&
        has_less_high_bit().ValueOrDefault() &&
        !less_high_bit().Equals(emboss_reserved_local_other.less_high_bit()))
      return false;



    if (!has_mid_nibble().Known()) return false;
    if (!emboss_reserved_local_other.has_mid_nibble().Known()) return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOrDefault() &&
        !has_mid_nibble().ValueOrDefault())
      return false;
    if (has_mid_nibble().ValueOrDefault() &&
        !emboss_reserved_local_other.has_mid_nibble().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOrDefault() &&
        has_mid_nibble().ValueOrDefault() &&
        !mid_nibble().Equals(emboss_reserved_local_other.mid_nibble()))
      return false;



    if (!has_less_low_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_less_low_bit().Known()) return false;

    if (emboss_reserved_local_other.has_less_low_bit().ValueOrDefault() &&
        !has_less_low_bit().ValueOrDefault())
      return false;
    if (has_less_low_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_less_low_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_less_low_bit().ValueOrDefault() &&
        has_less_low_bit().ValueOrDefault() &&
        !less_low_bit().Equals(emboss_reserved_local_other.less_low_bit()))
      return false;



    if (!has_low_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_low_bit().Known()) return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOrDefault() &&
        !has_low_bit().ValueOrDefault())
      return false;
    if (has_low_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_low_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOrDefault() &&
        has_low_bit().ValueOrDefault() &&
        !low_bit().Equals(emboss_reserved_local_other.low_bit()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericOneByteView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_high_bit().ValueOr(false) &&
        !has_high_bit().ValueOr(false))
      return false;
    if (has_high_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_high_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOr(false) &&
        has_high_bit().ValueOr(false) &&
        !high_bit().UncheckedEquals(emboss_reserved_local_other.high_bit()))
      return false;



    if (emboss_reserved_local_other.has_less_high_bit().ValueOr(false) &&
        !has_less_high_bit().ValueOr(false))
      return false;
    if (has_less_high_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_less_high_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_less_high_bit().ValueOr(false) &&
        has_less_high_bit().ValueOr(false) &&
        !less_high_bit().UncheckedEquals(emboss_reserved_local_other.less_high_bit()))
      return false;



    if (emboss_reserved_local_other.has_mid_nibble().ValueOr(false) &&
        !has_mid_nibble().ValueOr(false))
      return false;
    if (has_mid_nibble().ValueOr(false) &&
        !emboss_reserved_local_other.has_mid_nibble().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOr(false) &&
        has_mid_nibble().ValueOr(false) &&
        !mid_nibble().UncheckedEquals(emboss_reserved_local_other.mid_nibble()))
      return false;



    if (emboss_reserved_local_other.has_less_low_bit().ValueOr(false) &&
        !has_less_low_bit().ValueOr(false))
      return false;
    if (has_less_low_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_less_low_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_less_low_bit().ValueOr(false) &&
        has_less_low_bit().ValueOr(false) &&
        !less_low_bit().UncheckedEquals(emboss_reserved_local_other.less_low_bit()))
      return false;



    if (emboss_reserved_local_other.has_low_bit().ValueOr(false) &&
        !has_low_bit().ValueOr(false))
      return false;
    if (has_low_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_low_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOr(false) &&
        has_low_bit().ValueOr(false) &&
        !low_bit().UncheckedEquals(emboss_reserved_local_other.low_bit()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericOneByteView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericOneByteView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericOneByteView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "high_bit") {
        if (!high_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "less_high_bit") {
        if (!less_high_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "mid_nibble") {
        if (!mid_nibble().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "less_low_bit") {
        if (!less_low_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "low_bit") {
        if (!low_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_high_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          high_bit().IsAggregate() || high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("high_bit: ");
        high_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !high_bit().IsAggregate() && !high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# high_bit: UNREADABLE\n");
      }
    }

    if (has_less_high_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          less_high_bit().IsAggregate() || less_high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("less_high_bit: ");
        less_high_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !less_high_bit().IsAggregate() && !less_high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# less_high_bit: UNREADABLE\n");
      }
    }

    if (has_mid_nibble().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          mid_nibble().IsAggregate() || mid_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("mid_nibble: ");
        mid_nibble().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !mid_nibble().IsAggregate() && !mid_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# mid_nibble: UNREADABLE\n");
      }
    }

    if (has_less_low_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          less_low_bit().IsAggregate() || less_low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("less_low_bit: ");
        less_low_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !less_low_bit().IsAggregate() && !less_low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# less_low_bit: UNREADABLE\n");
      }
    }

    if (has_low_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          low_bit().IsAggregate() || low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("low_bit: ");
        low_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !low_bit().IsAggregate() && !low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# low_bit: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 7>>

 high_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_high_bit() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

 less_high_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_less_high_bit() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 2>>

 mid_nibble() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_mid_nibble() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 1>>

 less_low_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_less_low_bit() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 low_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_low_bit() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericOneByteView;
};
using OneByteView =
    GenericOneByteView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using OneByteWriter =
    GenericOneByteView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericOneByteView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericOneByteView<
    GenericOneByteView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericOneByteView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeOneByteView( T &&emboss_reserved_local_arg) {
  return GenericOneByteView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericOneByteView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeOneByteView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericOneByteView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericOneByteView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedOneByteView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericOneByteView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}



namespace FourByte {
struct EmbossReservedValidatorForRawLowNibble {
  template <typename ValueType>
  static constexpr bool ValueIsOk(ValueType emboss_reserved_local_value) {
    return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
           (::emboss::support::And</**/bool, bool, bool, bool>(::emboss::support::LessThanOrEqual</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)), ::emboss::support::Maybe</**/::std::int32_t>(emboss_reserved_local_value)), ::emboss::support::LessThanOrEqual</**/::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(15LL))))).ValueOrDefault();
  }
};


}  // namespace FourByte






namespace FourByte {





namespace TwoByteWithGaps {

}  // namespace TwoByteWithGaps


template <class View>
struct EmbossReservedInternalIsGenericTwoByteWithGapsView;

template <class Storage>
class GenericTwoByteWithGapsView final {
 public:
  GenericTwoByteWithGapsView() : backing_() {}
  explicit GenericTwoByteWithGapsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericTwoByteWithGapsView(
      const GenericTwoByteWithGapsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericTwoByteWithGapsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericTwoByteWithGapsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericTwoByteWithGapsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericTwoByteWithGapsView<Storage> &operator=(
      const GenericTwoByteWithGapsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!high_bit().Ok()) return false;
        if (!mid_nibble().Ok()) return false;
        if (!low_bit().Ok()) return false;
        if (!IntrinsicSizeInBits().Ok()) return false;
        if (!MaxSizeInBits().Ok()) return false;
        if (!MinSizeInBits().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericTwoByteWithGapsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_high_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_high_bit().Known()) return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOrDefault() &&
        !has_high_bit().ValueOrDefault())
      return false;
    if (has_high_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_high_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOrDefault() &&
        has_high_bit().ValueOrDefault() &&
        !high_bit().Equals(emboss_reserved_local_other.high_bit()))
      return false;



    if (!has_mid_nibble().Known()) return false;
    if (!emboss_reserved_local_other.has_mid_nibble().Known()) return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOrDefault() &&
        !has_mid_nibble().ValueOrDefault())
      return false;
    if (has_mid_nibble().ValueOrDefault() &&
        !emboss_reserved_local_other.has_mid_nibble().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOrDefault() &&
        has_mid_nibble().ValueOrDefault() &&
        !mid_nibble().Equals(emboss_reserved_local_other.mid_nibble()))
      return false;



    if (!has_low_bit().Known()) return false;
    if (!emboss_reserved_local_other.has_low_bit().Known()) return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOrDefault() &&
        !has_low_bit().ValueOrDefault())
      return false;
    if (has_low_bit().ValueOrDefault() &&
        !emboss_reserved_local_other.has_low_bit().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOrDefault() &&
        has_low_bit().ValueOrDefault() &&
        !low_bit().Equals(emboss_reserved_local_other.low_bit()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericTwoByteWithGapsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_high_bit().ValueOr(false) &&
        !has_high_bit().ValueOr(false))
      return false;
    if (has_high_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_high_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_high_bit().ValueOr(false) &&
        has_high_bit().ValueOr(false) &&
        !high_bit().UncheckedEquals(emboss_reserved_local_other.high_bit()))
      return false;



    if (emboss_reserved_local_other.has_mid_nibble().ValueOr(false) &&
        !has_mid_nibble().ValueOr(false))
      return false;
    if (has_mid_nibble().ValueOr(false) &&
        !emboss_reserved_local_other.has_mid_nibble().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_mid_nibble().ValueOr(false) &&
        has_mid_nibble().ValueOr(false) &&
        !mid_nibble().UncheckedEquals(emboss_reserved_local_other.mid_nibble()))
      return false;



    if (emboss_reserved_local_other.has_low_bit().ValueOr(false) &&
        !has_low_bit().ValueOr(false))
      return false;
    if (has_low_bit().ValueOr(false) &&
        !emboss_reserved_local_other.has_low_bit().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_low_bit().ValueOr(false) &&
        has_low_bit().ValueOr(false) &&
        !low_bit().UncheckedEquals(emboss_reserved_local_other.low_bit()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericTwoByteWithGapsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericTwoByteWithGapsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericTwoByteWithGapsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "high_bit") {
        if (!high_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "mid_nibble") {
        if (!mid_nibble().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "low_bit") {
        if (!low_bit().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_high_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          high_bit().IsAggregate() || high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("high_bit: ");
        high_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !high_bit().IsAggregate() && !high_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# high_bit: UNREADABLE\n");
      }
    }

    if (has_mid_nibble().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          mid_nibble().IsAggregate() || mid_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("mid_nibble: ");
        mid_nibble().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !mid_nibble().IsAggregate() && !mid_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# mid_nibble: UNREADABLE\n");
      }
    }

    if (has_low_bit().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          low_bit().IsAggregate() || low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("low_bit: ");
        low_bit().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !low_bit().IsAggregate() && !low_bit().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# low_bit: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

 high_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_high_bit() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

 mid_nibble() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_mid_nibble() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 low_bit() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_low_bit() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericTwoByteWithGapsView;
};
using TwoByteWithGapsView =
    GenericTwoByteWithGapsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using TwoByteWithGapsWriter =
    GenericTwoByteWithGapsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericTwoByteWithGapsView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericTwoByteWithGapsView<
    GenericTwoByteWithGapsView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericTwoByteWithGapsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeTwoByteWithGapsView( T &&emboss_reserved_local_arg) {
  return GenericTwoByteWithGapsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericTwoByteWithGapsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeTwoByteWithGapsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericTwoByteWithGapsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericTwoByteWithGapsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedTwoByteWithGapsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericTwoByteWithGapsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

}  // namespace FourByte


template <class View>
struct EmbossReservedInternalIsGenericFourByteView;

template <class Storage>
class GenericFourByteView final {
 public:
  GenericFourByteView() : backing_() {}
  explicit GenericFourByteView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericFourByteView(
      const GenericFourByteView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericFourByteView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericFourByteView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericFourByteView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericFourByteView<Storage> &operator=(
      const GenericFourByteView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!high_nibble().Ok()) return false;
        if (!one_byte().Ok()) return false;
        if (!two_byte().Ok()) return false;
        if (!raw_low_nibble().Ok()) return false;
        if (!low_nibble().Ok()) return false;
        if (!IntrinsicSizeInBits().Ok()) return false;
        if (!MaxSizeInBits().Ok()) return false;
        if (!MinSizeInBits().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericFourByteView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_high_nibble().Known()) return false;
    if (!emboss_reserved_local_other.has_high_nibble().Known()) return false;

    if (emboss_reserved_local_other.has_high_nibble().ValueOrDefault() &&
        !has_high_nibble().ValueOrDefault())
      return false;
    if (has_high_nibble().ValueOrDefault() &&
        !emboss_reserved_local_other.has_high_nibble().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_high_nibble().ValueOrDefault() &&
        has_high_nibble().ValueOrDefault() &&
        !high_nibble().Equals(emboss_reserved_local_other.high_nibble()))
      return false;



    if (!has_one_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_one_byte().Known()) return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        !has_one_byte().ValueOrDefault())
      return false;
    if (has_one_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_one_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        has_one_byte().ValueOrDefault() &&
        !one_byte().Equals(emboss_reserved_local_other.one_byte()))
      return false;



    if (!has_two_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_two_byte().Known()) return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOrDefault() &&
        !has_two_byte().ValueOrDefault())
      return false;
    if (has_two_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_two_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOrDefault() &&
        has_two_byte().ValueOrDefault() &&
        !two_byte().Equals(emboss_reserved_local_other.two_byte()))
      return false;



    if (!has_raw_low_nibble().Known()) return false;
    if (!emboss_reserved_local_other.has_raw_low_nibble().Known()) return false;

    if (emboss_reserved_local_other.has_raw_low_nibble().ValueOrDefault() &&
        !has_raw_low_nibble().ValueOrDefault())
      return false;
    if (has_raw_low_nibble().ValueOrDefault() &&
        !emboss_reserved_local_other.has_raw_low_nibble().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_raw_low_nibble().ValueOrDefault() &&
        has_raw_low_nibble().ValueOrDefault() &&
        !raw_low_nibble().Equals(emboss_reserved_local_other.raw_low_nibble()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericFourByteView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_high_nibble().ValueOr(false) &&
        !has_high_nibble().ValueOr(false))
      return false;
    if (has_high_nibble().ValueOr(false) &&
        !emboss_reserved_local_other.has_high_nibble().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_high_nibble().ValueOr(false) &&
        has_high_nibble().ValueOr(false) &&
        !high_nibble().UncheckedEquals(emboss_reserved_local_other.high_nibble()))
      return false;



    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        !has_one_byte().ValueOr(false))
      return false;
    if (has_one_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_one_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        has_one_byte().ValueOr(false) &&
        !one_byte().UncheckedEquals(emboss_reserved_local_other.one_byte()))
      return false;



    if (emboss_reserved_local_other.has_two_byte().ValueOr(false) &&
        !has_two_byte().ValueOr(false))
      return false;
    if (has_two_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_two_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOr(false) &&
        has_two_byte().ValueOr(false) &&
        !two_byte().UncheckedEquals(emboss_reserved_local_other.two_byte()))
      return false;



    if (emboss_reserved_local_other.has_raw_low_nibble().ValueOr(false) &&
        !has_raw_low_nibble().ValueOr(false))
      return false;
    if (has_raw_low_nibble().ValueOr(false) &&
        !emboss_reserved_local_other.has_raw_low_nibble().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_raw_low_nibble().ValueOr(false) &&
        has_raw_low_nibble().ValueOr(false) &&
        !raw_low_nibble().UncheckedEquals(emboss_reserved_local_other.raw_low_nibble()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericFourByteView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericFourByteView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericFourByteView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "high_nibble") {
        if (!high_nibble().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "one_byte") {
        if (!one_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "two_byte") {
        if (!two_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "raw_low_nibble") {
        if (!raw_low_nibble().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "low_nibble") {
        if (!low_nibble().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_high_nibble().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          high_nibble().IsAggregate() || high_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("high_nibble: ");
        high_nibble().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !high_nibble().IsAggregate() && !high_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# high_nibble: UNREADABLE\n");
      }
    }

    if (has_one_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          one_byte().IsAggregate() || one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("one_byte: ");
        one_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !one_byte().IsAggregate() && !one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# one_byte: UNREADABLE\n");
      }
    }

    if (has_two_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          two_byte().IsAggregate() || two_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("two_byte: ");
        two_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !two_byte().IsAggregate() && !two_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# two_byte: UNREADABLE\n");
      }
    }

    if (has_raw_low_nibble().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          raw_low_nibble().IsAggregate() || raw_low_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("raw_low_nibble: ");
        raw_low_nibble().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !raw_low_nibble().IsAggregate() && !raw_low_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# raw_low_nibble: UNREADABLE\n");
      }
    }

    if (has_low_nibble().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          low_nibble().IsAggregate() || low_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("low_nibble: ");
        low_nibble().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !low_nibble().IsAggregate() && !low_nibble().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# low_nibble: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 28>>

 high_nibble() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_high_nibble() const;

 public:
  [[nodiscard]] typename ::emboss::test::GenericOneByteView<typename Storage::template OffsetStorageType</**/0, 20>>

 one_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_one_byte() const;

 public:
  [[nodiscard]] typename ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename Storage::template OffsetStorageType</**/0, 4>>

 two_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_two_byte() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, FourByte::EmbossReservedValidatorForRawLowNibble>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 raw_low_nibble() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_raw_low_nibble() const;

 public:
  class EmbossReservedVirtualLowNibbleView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedVirtualLowNibbleView(
        const GenericFourByteView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedVirtualLowNibbleView() = delete;
    EmbossReservedVirtualLowNibbleView(const EmbossReservedVirtualLowNibbleView &) = default;
    EmbossReservedVirtualLowNibbleView(EmbossReservedVirtualLowNibbleView &&) = default;
    EmbossReservedVirtualLowNibbleView &operator=(const EmbossReservedVirtualLowNibbleView &) =
        default;
    EmbossReservedVirtualLowNibbleView &operator=(EmbossReservedVirtualLowNibbleView &&) =
        default;
    ~EmbossReservedVirtualLowNibbleView() = default;

    [[nodiscard]] ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_low_nibble().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    [[nodiscard]] ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    [[nodiscard]] bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }

    [[nodiscard]] bool TryToWrite(::std::int32_t emboss_reserved_local_value) {
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
      if (!CouldWriteValue(emboss_reserved_local_value)) return false;
      return view_.raw_low_nibble().TryToWrite(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    void Write(::std::int32_t emboss_reserved_local_value) {
      const bool result = TryToWrite(emboss_reserved_local_value);
      (void)result;
      EMBOSS_CHECK(result);
    }
    void UncheckedWrite(::std::int32_t emboss_reserved_local_value) {
      view_.raw_low_nibble().UncheckedWrite((::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)))).ValueOrDefault());
    }
    [[nodiscard]] bool CouldWriteValue(::std::int32_t emboss_reserved_local_value) {
      if (!ValueIsOk(emboss_reserved_local_value)) return false;
      const auto emboss_reserved_local_maybe_new_value = ::emboss::support::Difference</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/decltype(emboss_reserved_local_value)>(emboss_reserved_local_value), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));
      if (!emboss_reserved_local_maybe_new_value.Known()) return false;
      return view_.raw_low_nibble().CouldWriteValue(
          emboss_reserved_local_maybe_new_value.ValueOrDefault());
    }
    template <class Stream>
    bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) {
      return ::emboss::support::ReadIntegerFromTextStream(
          this, emboss_reserved_local_stream);
    }



   private:
    [[nodiscard]] ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.raw_low_nibble();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(100LL)));

      return emboss_reserved_local_subexpr_3;
    }

    [[nodiscard]] static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericFourByteView view_;
  };
  [[nodiscard]] EmbossReservedVirtualLowNibbleView low_nibble() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_low_nibble() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericFourByteView;
};
using FourByteView =
    GenericFourByteView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using FourByteWriter =
    GenericFourByteView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericFourByteView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericFourByteView<
    GenericFourByteView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericFourByteView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeFourByteView( T &&emboss_reserved_local_arg) {
  return GenericFourByteView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericFourByteView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeFourByteView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericFourByteView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericFourByteView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedFourByteView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericFourByteView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}




namespace ArrayInBits {

}  // namespace ArrayInBits


template <class View>
struct EmbossReservedInternalIsGenericArrayInBitsView;

template <class Storage>
class GenericArrayInBitsView final {
 public:
  GenericArrayInBitsView() : backing_() {}
  explicit GenericArrayInBitsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericArrayInBitsView(
      const GenericArrayInBitsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericArrayInBitsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericArrayInBitsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericArrayInBitsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericArrayInBitsView<Storage> &operator=(
      const GenericArrayInBitsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!lone_flag().Ok()) return false;
        if (!flags().Ok()) return false;
        if (!IntrinsicSizeInBits().Ok()) return false;
        if (!MaxSizeInBits().Ok()) return false;
        if (!MinSizeInBits().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBits().Ok() &&
           backing_.SizeInBits() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBits().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBits() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBits().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBits().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericArrayInBitsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_lone_flag().Known()) return false;
    if (!emboss_reserved_local_other.has_lone_flag().Known()) return false;

    if (emboss_reserved_local_other.has_lone_flag().ValueOrDefault() &&
        !has_lone_flag().ValueOrDefault())
      return false;
    if (has_lone_flag().ValueOrDefault() &&
        !emboss_reserved_local_other.has_lone_flag().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_lone_flag().ValueOrDefault() &&
        has_lone_flag().ValueOrDefault() &&
        !lone_flag().Equals(emboss_reserved_local_other.lone_flag()))
      return false;



    if (!has_flags().Known()) return false;
    if (!emboss_reserved_local_other.has_flags().Known()) return false;

    if (emboss_reserved_local_other.has_flags().ValueOrDefault() &&
        !has_flags().ValueOrDefault())
      return false;
    if (has_flags().ValueOrDefault() &&
        !emboss_reserved_local_other.has_flags().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_flags().ValueOrDefault() &&
        has_flags().ValueOrDefault() &&
        !flags().Equals(emboss_reserved_local_other.flags()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericArrayInBitsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_lone_flag().ValueOr(false) &&
        !has_lone_flag().ValueOr(false))
      return false;
    if (has_lone_flag().ValueOr(false) &&
        !emboss_reserved_local_other.has_lone_flag().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_lone_flag().ValueOr(false) &&
        has_lone_flag().ValueOr(false) &&
        !lone_flag().UncheckedEquals(emboss_reserved_local_other.lone_flag()))
      return false;



    if (emboss_reserved_local_other.has_flags().ValueOr(false) &&
        !has_flags().ValueOr(false))
      return false;
    if (has_flags().ValueOr(false) &&
        !emboss_reserved_local_other.has_flags().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_flags().ValueOr(false) &&
        has_flags().ValueOr(false) &&
        !flags().UncheckedEquals(emboss_reserved_local_other.flags()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericArrayInBitsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericArrayInBitsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericArrayInBitsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBits().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "lone_flag") {
        if (!lone_flag().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "flags") {
        if (!flags().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_lone_flag().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          lone_flag().IsAggregate() || lone_flag().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("lone_flag: ");
        lone_flag().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !lone_flag().IsAggregate() && !lone_flag().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# lone_flag: UNREADABLE\n");
      }
    }

    if (has_flags().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          flags().IsAggregate() || flags().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("flags: ");
        flags().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !flags().IsAggregate() && !flags().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# flags: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

 lone_flag() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_lone_flag() const;

 public:
  [[nodiscard]] typename ::emboss::support::GenericArrayView<
    typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    1 >

 flags() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_flags() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBitsView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBitsView IntrinsicSizeInBits() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBitsView() {}
    EmbossReservedDollarVirtualMaxSizeInBitsView(const EmbossReservedDollarVirtualMaxSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView(EmbossReservedDollarVirtualMaxSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(const EmbossReservedDollarVirtualMaxSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBitsView &operator=(EmbossReservedDollarVirtualMaxSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBitsView MaxSizeInBits() {
    return EmbossReservedDollarVirtualMaxSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBitsView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBitsView() {}
    EmbossReservedDollarVirtualMinSizeInBitsView(const EmbossReservedDollarVirtualMinSizeInBitsView &) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView(EmbossReservedDollarVirtualMinSizeInBitsView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(const EmbossReservedDollarVirtualMinSizeInBitsView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBitsView &operator=(EmbossReservedDollarVirtualMinSizeInBitsView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBitsView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBitsView MinSizeInBits() {
    return EmbossReservedDollarVirtualMinSizeInBitsView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBits() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericArrayInBitsView;
};
using ArrayInBitsView =
    GenericArrayInBitsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using ArrayInBitsWriter =
    GenericArrayInBitsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericArrayInBitsView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericArrayInBitsView<
    GenericArrayInBitsView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericArrayInBitsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeArrayInBitsView( T &&emboss_reserved_local_arg) {
  return GenericArrayInBitsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericArrayInBitsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeArrayInBitsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericArrayInBitsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericArrayInBitsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedArrayInBitsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericArrayInBitsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}



namespace ArrayInBitsInStruct {

}  // namespace ArrayInBitsInStruct


template <class View>
struct EmbossReservedInternalIsGenericArrayInBitsInStructView;

template <class Storage>
class GenericArrayInBitsInStructView final {
 public:
  GenericArrayInBitsInStructView() : backing_() {}
  explicit GenericArrayInBitsInStructView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericArrayInBitsInStructView(
      const GenericArrayInBitsInStructView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericArrayInBitsInStructView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericArrayInBitsInStructView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericArrayInBitsInStructView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericArrayInBitsInStructView<Storage> &operator=(
      const GenericArrayInBitsInStructView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!array_in_bits().Ok()) return false;
        if (!IntrinsicSizeInBytes().Ok()) return false;
        if (!MaxSizeInBytes().Ok()) return false;
        if (!MinSizeInBytes().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericArrayInBitsInStructView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_array_in_bits().Known()) return false;
    if (!emboss_reserved_local_other.has_array_in_bits().Known()) return false;

    if (emboss_reserved_local_other.has_array_in_bits().ValueOrDefault() &&
        !has_array_in_bits().ValueOrDefault())
      return false;
    if (has_array_in_bits().ValueOrDefault() &&
        !emboss_reserved_local_other.has_array_in_bits().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_array_in_bits().ValueOrDefault() &&
        has_array_in_bits().ValueOrDefault() &&
        !array_in_bits().Equals(emboss_reserved_local_other.array_in_bits()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericArrayInBitsInStructView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_array_in_bits().ValueOr(false) &&
        !has_array_in_bits().ValueOr(false))
      return false;
    if (has_array_in_bits().ValueOr(false) &&
        !emboss_reserved_local_other.has_array_in_bits().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_array_in_bits().ValueOr(false) &&
        has_array_in_bits().ValueOr(false) &&
        !array_in_bits().UncheckedEquals(emboss_reserved_local_other.array_in_bits()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericArrayInBitsInStructView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericArrayInBitsInStructView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericArrayInBitsInStructView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "array_in_bits") {
        if (!array_in_bits().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_array_in_bits().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          array_in_bits().IsAggregate() || array_in_bits().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("array_in_bits: ");
        array_in_bits().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !array_in_bits().IsAggregate() && !array_in_bits().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# array_in_bits: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::test::GenericArrayInBitsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

 array_in_bits() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_array_in_bits() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericArrayInBitsInStructView;
};
using ArrayInBitsInStructView =
    GenericArrayInBitsInStructView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using ArrayInBitsInStructWriter =
    GenericArrayInBitsInStructView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericArrayInBitsInStructView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericArrayInBitsInStructView<
    GenericArrayInBitsInStructView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericArrayInBitsInStructView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeArrayInBitsInStructView( T &&emboss_reserved_local_arg) {
  return GenericArrayInBitsInStructView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericArrayInBitsInStructView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeArrayInBitsInStructView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericArrayInBitsInStructView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericArrayInBitsInStructView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedArrayInBitsInStructView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericArrayInBitsInStructView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}






namespace StructOfBits {

}  // namespace StructOfBits


template <class View>
struct EmbossReservedInternalIsGenericStructOfBitsView;

template <class Storage>
class GenericStructOfBitsView final {
 public:
  GenericStructOfBitsView() : backing_() {}
  explicit GenericStructOfBitsView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericStructOfBitsView(
      const GenericStructOfBitsView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericStructOfBitsView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericStructOfBitsView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericStructOfBitsView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericStructOfBitsView<Storage> &operator=(
      const GenericStructOfBitsView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!one_byte().Ok()) return false;
        if (!two_byte().Ok()) return false;
        if (!four_byte().Ok()) return false;
        if (!located_byte().Ok()) return false;
        if (!IntrinsicSizeInBytes().Ok()) return false;
        if (!MaxSizeInBytes().Ok()) return false;
        if (!MinSizeInBytes().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  [[nodiscard]] ::std::size_t SizeInBytes() const {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  [[nodiscard]] bool SizeIsKnown() const { return IntrinsicSizeInBytes().Ok(); }



  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericStructOfBitsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_one_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_one_byte().Known()) return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        !has_one_byte().ValueOrDefault())
      return false;
    if (has_one_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_one_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        has_one_byte().ValueOrDefault() &&
        !one_byte().Equals(emboss_reserved_local_other.one_byte()))
      return false;



    if (!has_two_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_two_byte().Known()) return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOrDefault() &&
        !has_two_byte().ValueOrDefault())
      return false;
    if (has_two_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_two_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOrDefault() &&
        has_two_byte().ValueOrDefault() &&
        !two_byte().Equals(emboss_reserved_local_other.two_byte()))
      return false;



    if (!has_four_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_four_byte().Known()) return false;

    if (emboss_reserved_local_other.has_four_byte().ValueOrDefault() &&
        !has_four_byte().ValueOrDefault())
      return false;
    if (has_four_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_four_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_four_byte().ValueOrDefault() &&
        has_four_byte().ValueOrDefault() &&
        !four_byte().Equals(emboss_reserved_local_other.four_byte()))
      return false;



    if (!has_located_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_located_byte().Known()) return false;

    if (emboss_reserved_local_other.has_located_byte().ValueOrDefault() &&
        !has_located_byte().ValueOrDefault())
      return false;
    if (has_located_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_located_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_located_byte().ValueOrDefault() &&
        has_located_byte().ValueOrDefault() &&
        !located_byte().Equals(emboss_reserved_local_other.located_byte()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericStructOfBitsView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        !has_one_byte().ValueOr(false))
      return false;
    if (has_one_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_one_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        has_one_byte().ValueOr(false) &&
        !one_byte().UncheckedEquals(emboss_reserved_local_other.one_byte()))
      return false;



    if (emboss_reserved_local_other.has_two_byte().ValueOr(false) &&
        !has_two_byte().ValueOr(false))
      return false;
    if (has_two_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_two_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_two_byte().ValueOr(false) &&
        has_two_byte().ValueOr(false) &&
        !two_byte().UncheckedEquals(emboss_reserved_local_other.two_byte()))
      return false;



    if (emboss_reserved_local_other.has_four_byte().ValueOr(false) &&
        !has_four_byte().ValueOr(false))
      return false;
    if (has_four_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_four_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_four_byte().ValueOr(false) &&
        has_four_byte().ValueOr(false) &&
        !four_byte().UncheckedEquals(emboss_reserved_local_other.four_byte()))
      return false;



    if (emboss_reserved_local_other.has_located_byte().ValueOr(false) &&
        !has_located_byte().ValueOr(false))
      return false;
    if (has_located_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_located_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_located_byte().ValueOr(false) &&
        has_located_byte().ValueOr(false) &&
        !located_byte().UncheckedEquals(emboss_reserved_local_other.located_byte()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericStructOfBitsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericStructOfBitsView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericStructOfBitsView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "one_byte") {
        if (!one_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "two_byte") {
        if (!two_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "four_byte") {
        if (!four_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      if (emboss_reserved_local_name == "located_byte") {
        if (!located_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_one_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          one_byte().IsAggregate() || one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("one_byte: ");
        one_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !one_byte().IsAggregate() && !one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# one_byte: UNREADABLE\n");
      }
    }

    if (has_two_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          two_byte().IsAggregate() || two_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("two_byte: ");
        two_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !two_byte().IsAggregate() && !two_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# two_byte: UNREADABLE\n");
      }
    }

    if (has_four_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          four_byte().IsAggregate() || four_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("four_byte: ");
        four_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !four_byte().IsAggregate() && !four_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# four_byte: UNREADABLE\n");
      }
    }

    if (has_located_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          located_byte().IsAggregate() || located_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("located_byte: ");
        located_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !located_byte().IsAggregate() && !located_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# located_byte: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 one_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_one_byte() const;

 public:
  [[nodiscard]] typename ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 16>>

 two_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_two_byte() const;

 public:
  [[nodiscard]] typename ::emboss::test::GenericFourByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 3>>, 32>>

 four_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_four_byte() const;

 public:
  [[nodiscard]] typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/1, 0>>, 8>>

 located_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_located_byte() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    explicit EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
        const GenericStructOfBitsView &emboss_reserved_local_view)
        : view_(emboss_reserved_local_view) {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = delete;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    [[nodiscard]] ::std::int32_t Read() const {
      EMBOSS_CHECK(view_.has_IntrinsicSizeInBytes().ValueOr(false));
      auto emboss_reserved_local_value = MaybeRead();
      EMBOSS_CHECK(emboss_reserved_local_value.Known());
      EMBOSS_CHECK(ValueIsOk(emboss_reserved_local_value.ValueOrDefault()));
      return emboss_reserved_local_value.ValueOrDefault();
    }
    [[nodiscard]] ::std::int32_t UncheckedRead() const {
      return MaybeRead().ValueOrDefault();
    }
    [[nodiscard]] bool Ok() const {
      auto emboss_reserved_local_value = MaybeRead();
      return emboss_reserved_local_value.Known() &&
             ValueIsOk(emboss_reserved_local_value.ValueOrDefault());
    }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }



   private:
    [[nodiscard]] ::emboss::support::Maybe</**/ ::std::int32_t> MaybeRead() const {
      const auto emboss_reserved_local_subexpr_1 = view_.one_byte().mid_nibble();
      const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());
      const auto emboss_reserved_local_subexpr_3 = ::emboss::support::Sum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(emboss_reserved_local_subexpr_2, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)));
      const auto emboss_reserved_local_subexpr_4 = ::emboss::support::Choice</**/::std::int32_t, ::std::int32_t, bool, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/bool>(true), emboss_reserved_local_subexpr_3, ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)));
      const auto emboss_reserved_local_subexpr_5 = ::emboss::support::Maximum</**/::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t, ::std::int32_t>(::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(3LL)), ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(7LL)), emboss_reserved_local_subexpr_4);

      return emboss_reserved_local_subexpr_5;
    }

    [[nodiscard]] static constexpr bool ValueIsOk(
        ::std::int32_t emboss_reserved_local_value) {
      return (void)emboss_reserved_local_value,  // Silence -Wunused-parameter
             ::emboss::support::Maybe<bool>(true).ValueOr(false);
    }

    const GenericStructOfBitsView view_;
  };
  [[nodiscard]] EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() const;

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericStructOfBitsView;
};
using StructOfBitsView =
    GenericStructOfBitsView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using StructOfBitsWriter =
    GenericStructOfBitsView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericStructOfBitsView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericStructOfBitsView<
    GenericStructOfBitsView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericStructOfBitsView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeStructOfBitsView( T &&emboss_reserved_local_arg) {
  return GenericStructOfBitsView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericStructOfBitsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeStructOfBitsView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericStructOfBitsView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericStructOfBitsView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedStructOfBitsView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericStructOfBitsView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}



namespace BitArray {

}  // namespace BitArray


template <class View>
struct EmbossReservedInternalIsGenericBitArrayView;

template <class Storage>
class GenericBitArrayView final {
 public:
  GenericBitArrayView() : backing_() {}
  explicit GenericBitArrayView(
       Storage emboss_reserved_local_bytes)
      : backing_(emboss_reserved_local_bytes) 
         {}

  template <typename OtherStorage>
  GenericBitArrayView(
      const GenericBitArrayView<OtherStorage> &emboss_reserved_local_other)
      : backing_{emboss_reserved_local_other.BackingStorage()}
         {}

  template <typename Arg,
            typename = typename ::std::enable_if<
                !EmbossReservedInternalIsGenericBitArrayView<
                    typename ::std::remove_cv<typename ::std::remove_reference<
                        Arg>::type>::type>::value>::type>
  explicit GenericBitArrayView(
       Arg &&emboss_reserved_local_arg)
      : backing_(::std::forward<Arg>(
            emboss_reserved_local_arg)) 
         {}
  template <typename Arg0, typename Arg1, typename... Args>
  explicit GenericBitArrayView(
       Arg0 &&emboss_reserved_local_arg0,
      Arg1 &&emboss_reserved_local_arg1, Args &&... emboss_reserved_local_args)
      : backing_(::std::forward<Arg0>(emboss_reserved_local_arg0),
                 ::std::forward<Arg1>(emboss_reserved_local_arg1),
                 ::std::forward<Args>(
                     emboss_reserved_local_args)...) 
         {}

  template <typename OtherStorage>
  GenericBitArrayView<Storage> &operator=(
      const GenericBitArrayView<OtherStorage> &emboss_reserved_local_other) {
    backing_ = emboss_reserved_local_other.BackingStorage();
    return *this;
  }

  

  [[nodiscard]] bool Ok() const {
    if (!IsComplete()) return false;


    {
      const auto emboss_reserved_cond = ::emboss::support::Maybe</**/bool>(true);
      if (!emboss_reserved_cond.Known()) return false;
      if (emboss_reserved_cond.ValueOrDefault()) {
        if (!one_byte().Ok()) return false;
        if (!IntrinsicSizeInBytes().Ok()) return false;
        if (!MaxSizeInBytes().Ok()) return false;
        if (!MinSizeInBytes().Ok()) return false;
      }
    }

    return true;
  }
  [[nodiscard]] Storage BackingStorage() const { return backing_; }
  [[nodiscard]] bool IsComplete() const {
    return backing_.Ok() && IntrinsicSizeInBytes().Ok() &&
           backing_.SizeInBytes() >=
               static_cast</**/ ::std::size_t>(
                   IntrinsicSizeInBytes().UncheckedRead());
  }
  [[nodiscard]] static constexpr ::std::size_t SizeInBytes() {
    return static_cast</**/ ::std::size_t>(IntrinsicSizeInBytes().Read());
  }
  [[nodiscard]] static constexpr bool SizeIsKnown() {
    return IntrinsicSizeInBytes().Ok();
  }


  template <typename OtherStorage>
  [[nodiscard]] bool Equals(
      GenericBitArrayView<OtherStorage> emboss_reserved_local_other) const {
    
    if (!has_one_byte().Known()) return false;
    if (!emboss_reserved_local_other.has_one_byte().Known()) return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        !has_one_byte().ValueOrDefault())
      return false;
    if (has_one_byte().ValueOrDefault() &&
        !emboss_reserved_local_other.has_one_byte().ValueOrDefault())
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOrDefault() &&
        has_one_byte().ValueOrDefault() &&
        !one_byte().Equals(emboss_reserved_local_other.one_byte()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  [[nodiscard]] bool UncheckedEquals(
      GenericBitArrayView<OtherStorage> emboss_reserved_local_other) const {
    
    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        !has_one_byte().ValueOr(false))
      return false;
    if (has_one_byte().ValueOr(false) &&
        !emboss_reserved_local_other.has_one_byte().ValueOr(false))
      return false;

    if (emboss_reserved_local_other.has_one_byte().ValueOr(false) &&
        has_one_byte().ValueOr(false) &&
        !one_byte().UncheckedEquals(emboss_reserved_local_other.one_byte()))
      return false;

 return true;
  }
  template <typename OtherStorage>
  void UncheckedCopyFrom(
      GenericBitArrayView<OtherStorage> emboss_reserved_local_other) const {
    backing_.UncheckedCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().UncheckedRead());
  }

  template <typename OtherStorage>
  void CopyFrom(
      GenericBitArrayView<OtherStorage> emboss_reserved_local_other) const {
    backing_.CopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }
  template <typename OtherStorage>
  [[nodiscard]] bool TryToCopyFrom(
      GenericBitArrayView<OtherStorage> emboss_reserved_local_other) const {
      return emboss_reserved_local_other.Ok() && backing_.TryToCopyFrom(
        emboss_reserved_local_other.BackingStorage(),
        emboss_reserved_local_other.IntrinsicSizeInBytes().Read());
  }

  template <class Stream>
  bool UpdateFromTextStream(Stream *emboss_reserved_local_stream) const {
    ::std::string emboss_reserved_local_brace;
    if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                      &emboss_reserved_local_brace))
      return false;
    if (emboss_reserved_local_brace != "{") return false;
    for (;;) {
      ::std::string emboss_reserved_local_name;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_name))
        return false;
      if (emboss_reserved_local_name == ",")
        if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                          &emboss_reserved_local_name))
          return false;
      if (emboss_reserved_local_name == "}") return true;
      ::std::string emboss_reserved_local_colon;
      if (!::emboss::support::ReadToken(emboss_reserved_local_stream,
                                        &emboss_reserved_local_colon))
        return false;
      if (emboss_reserved_local_colon != ":") return false;
      if (emboss_reserved_local_name == "one_byte") {
        if (!one_byte().UpdateFromTextStream(
                emboss_reserved_local_stream)) {
          return false;
        }
        continue;
      }

      return false;
    }
  }

  template <class Stream>
  void WriteToTextStream(
      Stream *emboss_reserved_local_stream,
      ::emboss::TextOutputOptions emboss_reserved_local_options) const {
    ::emboss::TextOutputOptions emboss_reserved_local_field_options =
        emboss_reserved_local_options.PlusOneIndent();
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write("{\n");
    } else {
      emboss_reserved_local_stream->Write("{");
    }
    bool emboss_reserved_local_wrote_field = false;
    if (has_one_byte().ValueOr(false)) {
      if (!emboss_reserved_local_field_options.allow_partial_output() ||
          one_byte().IsAggregate() || one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        } else {
          if (emboss_reserved_local_wrote_field) {
            emboss_reserved_local_stream->Write(",");
          }
          emboss_reserved_local_stream->Write(" ");
        }
        emboss_reserved_local_stream->Write("one_byte: ");
        one_byte().WriteToTextStream(emboss_reserved_local_stream,
                                           emboss_reserved_local_field_options);
        emboss_reserved_local_wrote_field = true;
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write("\n");
        }
      } else if (emboss_reserved_local_field_options.allow_partial_output() &&
                 emboss_reserved_local_field_options.comments() &&
                 !one_byte().IsAggregate() && !one_byte().Ok()) {
        if (emboss_reserved_local_field_options.multiline()) {
          emboss_reserved_local_stream->Write(
              emboss_reserved_local_field_options.current_indent());
        }
        emboss_reserved_local_stream->Write("# one_byte: UNREADABLE\n");
      }
    }

    (void)emboss_reserved_local_wrote_field;
    if (emboss_reserved_local_options.multiline()) {
      emboss_reserved_local_stream->Write(
          emboss_reserved_local_options.current_indent());
      emboss_reserved_local_stream->Write("}");
    } else {
      emboss_reserved_local_stream->Write(" }");
    }
  }



  [[nodiscard]] static constexpr bool IsAggregate() { return true; }

 public:
  [[nodiscard]] typename ::emboss::support::GenericArrayView<
    typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>, 8>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    8 >

 one_byte() const;
  [[nodiscard]] ::emboss::support::Maybe<bool> has_one_byte() const;

 public:
  class EmbossReservedDollarVirtualIntrinsicSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView() {}
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(const EmbossReservedDollarVirtualIntrinsicSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualIntrinsicSizeInBytesView &operator=(EmbossReservedDollarVirtualIntrinsicSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualIntrinsicSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualIntrinsicSizeInBytesView IntrinsicSizeInBytes() {
    return EmbossReservedDollarVirtualIntrinsicSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_IntrinsicSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMaxSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMaxSizeInBytesView() {}
    EmbossReservedDollarVirtualMaxSizeInBytesView(const EmbossReservedDollarVirtualMaxSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView(EmbossReservedDollarVirtualMaxSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(const EmbossReservedDollarVirtualMaxSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMaxSizeInBytesView &operator=(EmbossReservedDollarVirtualMaxSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMaxSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMaxSizeInBytesView MaxSizeInBytes() {
    return EmbossReservedDollarVirtualMaxSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MaxSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }

 public:
  class EmbossReservedDollarVirtualMinSizeInBytesView final {
   public:
    using ValueType = ::std::int32_t;

    constexpr EmbossReservedDollarVirtualMinSizeInBytesView() {}
    EmbossReservedDollarVirtualMinSizeInBytesView(const EmbossReservedDollarVirtualMinSizeInBytesView &) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView(EmbossReservedDollarVirtualMinSizeInBytesView &&) = default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(const EmbossReservedDollarVirtualMinSizeInBytesView &) =
        default;
    EmbossReservedDollarVirtualMinSizeInBytesView &operator=(EmbossReservedDollarVirtualMinSizeInBytesView &&) =
        default;
    ~EmbossReservedDollarVirtualMinSizeInBytesView() = default;

    [[nodiscard]] static constexpr ::std::int32_t Read();
    [[nodiscard]] static constexpr ::std::int32_t UncheckedRead();
    [[nodiscard]] static constexpr bool Ok() { return true; }
    template <class Stream>
    void WriteToTextStream(Stream *emboss_reserved_local_stream,
                           const ::emboss::TextOutputOptions
                               &emboss_reserved_local_options) const {
      ::emboss::support::WriteIntegerViewToTextStream(
          this, emboss_reserved_local_stream, emboss_reserved_local_options);
    }

    [[nodiscard]] static constexpr bool IsAggregate() { return false; }
  };

  [[nodiscard]] static constexpr EmbossReservedDollarVirtualMinSizeInBytesView MinSizeInBytes() {
    return EmbossReservedDollarVirtualMinSizeInBytesView();
  }
  [[nodiscard]] static constexpr ::emboss::support::Maybe<bool> has_MinSizeInBytes() {
    return ::emboss::support::Maybe<bool>(true);
  }



 private:
  Storage backing_;
  
  

  template <class OtherStorage>
  friend class GenericBitArrayView;
};
using BitArrayView =
    GenericBitArrayView</**/ ::emboss::support::ReadOnlyContiguousBuffer>;
using BitArrayWriter =
    GenericBitArrayView</**/ ::emboss::support::ReadWriteContiguousBuffer>;

template <class View>
struct EmbossReservedInternalIsGenericBitArrayView {
  static constexpr const bool value = false;
};

template <class Storage>
struct EmbossReservedInternalIsGenericBitArrayView<
    GenericBitArrayView<Storage>> {
  static constexpr const bool value = true;
};

template <typename T>
[[nodiscard]] inline GenericBitArrayView<
    /**/ ::emboss::support::ContiguousBuffer<
        typename ::std::remove_reference<
            decltype(*::std::declval<T>()->data())>::type,
        1, 0>>
MakeBitArrayView( T &&emboss_reserved_local_arg) {
  return GenericBitArrayView<
      /**/ ::emboss::support::ContiguousBuffer<
          typename ::std::remove_reference<decltype(
              *::std::declval<T>()->data())>::type,
          1, 0>>(
       ::std::forward<T>(emboss_reserved_local_arg));
}

template <typename T>
[[nodiscard]] inline GenericBitArrayView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>
MakeBitArrayView( T *emboss_reserved_local_data,
                 ::std::size_t emboss_reserved_local_size) {
  return GenericBitArrayView</**/ ::emboss::support::ContiguousBuffer<T, 1, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

template <typename T, ::std::size_t kAlignment>
[[nodiscard]] inline GenericBitArrayView<
    /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>
MakeAlignedBitArrayView(
     T *emboss_reserved_local_data,
    ::std::size_t emboss_reserved_local_size) {
  return GenericBitArrayView<
      /**/ ::emboss::support::ContiguousBuffer<T, kAlignment, 0>>(
       emboss_reserved_local_data,
      emboss_reserved_local_size);
}

namespace OneByte {

}  // namespace OneByte


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 7>>

 GenericOneByteView<Storage>::high_bit()
    const {

  if ( has_high_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(7LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 7>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   7>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 7>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericOneByteView<Storage>::has_high_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

 GenericOneByteView<Storage>::less_high_bit()
    const {

  if ( has_less_high_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(6LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   6>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericOneByteView<Storage>::has_less_high_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 2>>

 GenericOneByteView<Storage>::mid_nibble()
    const {

  if ( has_mid_nibble().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 2>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   2>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 2>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericOneByteView<Storage>::has_mid_nibble() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 1>>

 GenericOneByteView<Storage>::less_low_bit()
    const {

  if ( has_less_low_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 1>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   1>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 1>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericOneByteView<Storage>::has_less_low_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 GenericOneByteView<Storage>::low_bit()
    const {

  if ( has_low_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericOneByteView<Storage>::has_low_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace OneByte {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace OneByte

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return OneByte::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return OneByte::IntrinsicSizeInBits();
}

namespace OneByte {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace OneByte

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return OneByte::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return OneByte::MaxSizeInBits();
}

namespace OneByte {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace OneByte

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return OneByte::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericOneByteView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return OneByte::MinSizeInBits();
}
namespace FourByte {
namespace TwoByteWithGaps {

}  // namespace TwoByteWithGaps


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

 GenericTwoByteWithGapsView<Storage>::high_bit()
    const {

  if ( has_high_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(15LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   15>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericTwoByteWithGapsView<Storage>::has_high_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

 GenericTwoByteWithGapsView<Storage>::mid_nibble()
    const {

  if ( has_mid_nibble().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(6LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   6>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 6>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericTwoByteWithGapsView<Storage>::has_mid_nibble() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 GenericTwoByteWithGapsView<Storage>::low_bit()
    const {

  if ( has_low_bit().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericTwoByteWithGapsView<Storage>::has_low_bit() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace TwoByteWithGaps {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace TwoByteWithGaps

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return TwoByteWithGaps::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return TwoByteWithGaps::IntrinsicSizeInBits();
}

namespace TwoByteWithGaps {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace TwoByteWithGaps

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return TwoByteWithGaps::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return TwoByteWithGaps::MaxSizeInBits();
}

namespace TwoByteWithGaps {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace TwoByteWithGaps

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return TwoByteWithGaps::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericTwoByteWithGapsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return TwoByteWithGaps::MinSizeInBits();
}

}  // namespace FourByte


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 28>>

 GenericFourByteView<Storage>::high_nibble()
    const {

  if ( has_high_nibble().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(28LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 28>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   28>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 28>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFourByteView<Storage>::has_high_nibble() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::GenericOneByteView<typename Storage::template OffsetStorageType</**/0, 20>>

 GenericFourByteView<Storage>::one_byte()
    const {

  if ( has_one_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(20LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericOneByteView<typename Storage::template OffsetStorageType</**/0, 20>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   20>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericOneByteView<typename Storage::template OffsetStorageType</**/0, 20>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFourByteView<Storage>::has_one_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename Storage::template OffsetStorageType</**/0, 4>>

 GenericFourByteView<Storage>::two_byte()
    const {

  if ( has_two_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename Storage::template OffsetStorageType</**/0, 4>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   4>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename Storage::template OffsetStorageType</**/0, 4>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFourByteView<Storage>::has_two_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, FourByte::EmbossReservedValidatorForRawLowNibble>,
    typename Storage::template OffsetStorageType</**/0, 0>>

 GenericFourByteView<Storage>::raw_low_nibble()
    const {

  if ( has_raw_low_nibble().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, FourByte::EmbossReservedValidatorForRawLowNibble>,
    typename Storage::template OffsetStorageType</**/0, 0>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<4, FourByte::EmbossReservedValidatorForRawLowNibble>,
    typename Storage::template OffsetStorageType</**/0, 0>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFourByteView<Storage>::has_raw_low_nibble() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericFourByteView<Storage>::EmbossReservedVirtualLowNibbleView
GenericFourByteView<Storage>::low_nibble() const {
  return
      typename GenericFourByteView<Storage>::EmbossReservedVirtualLowNibbleView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericFourByteView<Storage>::has_low_nibble() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace FourByte {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace FourByte

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return FourByte::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return FourByte::IntrinsicSizeInBits();
}

namespace FourByte {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace FourByte

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return FourByte::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return FourByte::MaxSizeInBits();
}

namespace FourByte {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(32LL)).ValueOrDefault();
}
}  // namespace FourByte

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return FourByte::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericFourByteView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return FourByte::MinSizeInBits();
}
namespace ArrayInBits {

}  // namespace ArrayInBits


template <class Storage>
inline typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

 GenericArrayInBitsView<Storage>::lone_flag()
    const {

  if ( has_lone_flag().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(15LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   15>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 15>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericArrayInBitsView<Storage>::has_lone_flag() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::support::GenericArrayView<
    typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    1 >

 GenericArrayInBitsView<Storage>::flags()
    const {

  if ( has_flags().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(12LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::support::GenericArrayView<
    typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    1 >

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::support::GenericArrayView<
    typename ::emboss::prelude::FlagView<
    /**/ ::emboss::support::FixedSizeViewParameters<1, ::emboss::support::AllValuesAreOk>,
    typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    1 >

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericArrayInBitsView<Storage>::has_flags() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace ArrayInBits {
inline constexpr ::std::int32_t IntrinsicSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace ArrayInBits

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::Read() {
  return ArrayInBits::IntrinsicSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBitsView::UncheckedRead() {
  return ArrayInBits::IntrinsicSizeInBits();
}

namespace ArrayInBits {
inline constexpr ::std::int32_t MaxSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace ArrayInBits

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::Read() {
  return ArrayInBits::MaxSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBitsView::UncheckedRead() {
  return ArrayInBits::MaxSizeInBits();
}

namespace ArrayInBits {
inline constexpr ::std::int32_t MinSizeInBits() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace ArrayInBits

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::Read() {
  return ArrayInBits::MinSizeInBits();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBitsView::UncheckedRead() {
  return ArrayInBits::MinSizeInBits();
}
namespace ArrayInBitsInStruct {

}  // namespace ArrayInBitsInStruct


template <class Storage>
inline typename ::emboss::test::GenericArrayInBitsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

 GenericArrayInBitsInStructView<Storage>::array_in_bits()
    const {

  if ( has_array_in_bits().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericArrayInBitsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericArrayInBitsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 16>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericArrayInBitsInStructView<Storage>::has_array_in_bits() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace ArrayInBitsInStruct {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)).ValueOrDefault();
}
}  // namespace ArrayInBitsInStruct

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return ArrayInBitsInStruct::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return ArrayInBitsInStruct::IntrinsicSizeInBytes();
}

namespace ArrayInBitsInStruct {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)).ValueOrDefault();
}
}  // namespace ArrayInBitsInStruct

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return ArrayInBitsInStruct::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return ArrayInBitsInStruct::MaxSizeInBytes();
}

namespace ArrayInBitsInStruct {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL)).ValueOrDefault();
}
}  // namespace ArrayInBitsInStruct

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return ArrayInBitsInStruct::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericArrayInBitsInStructView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return ArrayInBitsInStruct::MinSizeInBytes();
}
namespace StructOfBits {

}  // namespace StructOfBits


template <class Storage>
inline typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

 GenericStructOfBitsView<Storage>::one_byte()
    const {

  if ( has_one_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructOfBitsView<Storage>::has_one_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 16>>

 GenericStructOfBitsView<Storage>::two_byte()
    const {

  if ( has_two_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(2LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 16>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   1>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::FourByte::GenericTwoByteWithGapsView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 1>>, 16>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructOfBitsView<Storage>::has_two_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::test::GenericFourByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 3>>, 32>>

 GenericStructOfBitsView<Storage>::four_byte()
    const {

  if ( has_four_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(4LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(3LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::test::GenericFourByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 3>>, 32>>

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   3>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::test::GenericFourByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 3>>, 32>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructOfBitsView<Storage>::has_four_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/1, 0>>, 8>>

 GenericStructOfBitsView<Storage>::located_byte()
    const {

  if ( has_located_byte().ValueOr(false)) {
    const auto emboss_reserved_local_subexpr_1 = one_byte().mid_nibble();
    const auto emboss_reserved_local_subexpr_2 = (emboss_reserved_local_subexpr_1.Ok()    ? ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(emboss_reserved_local_subexpr_1.UncheckedRead()))    : ::emboss::support::Maybe</**/::std::int32_t>());

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(1LL));
    auto emboss_reserved_local_offset = emboss_reserved_local_subexpr_2;
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/1, 0>>, 8>>

(
                 backing_
                        .template GetOffsetStorage<1,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::prelude::UIntView<
    /**/ ::emboss::support::FixedSizeViewParameters<8, ::emboss::support::AllValuesAreOk>,
    typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/1, 0>>, 8>>

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructOfBitsView<Storage>::has_located_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


template <class Storage>
inline typename GenericStructOfBitsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView
GenericStructOfBitsView<Storage>::IntrinsicSizeInBytes() const {
  return
      typename GenericStructOfBitsView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView(
          *this);
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericStructOfBitsView<Storage>::has_IntrinsicSizeInBytes() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace StructOfBits {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(16LL)).ValueOrDefault();
}
}  // namespace StructOfBits

template <class Storage>
inline constexpr ::std::int32_t
GenericStructOfBitsView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return StructOfBits::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructOfBitsView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return StructOfBits::MaxSizeInBytes();
}

namespace StructOfBits {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(7LL)).ValueOrDefault();
}
}  // namespace StructOfBits

template <class Storage>
inline constexpr ::std::int32_t
GenericStructOfBitsView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return StructOfBits::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericStructOfBitsView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return StructOfBits::MinSizeInBytes();
}
namespace BitArray {

}  // namespace BitArray


template <class Storage>
inline typename ::emboss::support::GenericArrayView<
    typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>, 8>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    8 >

 GenericBitArrayView<Storage>::one_byte()
    const {

  if ( has_one_byte().ValueOr(false)) {

    auto emboss_reserved_local_size = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL));
    auto emboss_reserved_local_offset = ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(0LL));
    if (emboss_reserved_local_size.Known() &&
        emboss_reserved_local_size.ValueOr(0) >= 0 &&
        emboss_reserved_local_offset.Known() &&
        emboss_reserved_local_offset.ValueOr(0) >= 0) {
        return ::emboss::support::GenericArrayView<
    typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>, 8>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    8 >

(
                 backing_
                        .template GetOffsetStorage<0,
                                                   0>(
                                emboss_reserved_local_offset.ValueOrDefault(),
                                emboss_reserved_local_size.ValueOrDefault()));
    }
  }
  return ::emboss::support::GenericArrayView<
    typename ::emboss::test::GenericOneByteView<typename ::emboss::support::BitBlock</**/::emboss::support::LittleEndianByteOrderer<typename Storage::template OffsetStorageType</**/0, 0>::template OffsetStorageType</**/1, 0>>, 8>>

, typename Storage::template OffsetStorageType</**/0, 0>, 1,
    8 >

();
}

template <class Storage>
inline ::emboss::support::Maybe<bool>
GenericBitArrayView<Storage>::has_one_byte() const {
  return ::emboss::support::Maybe</**/bool>(true);
}


namespace BitArray {
inline constexpr ::std::int32_t IntrinsicSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace BitArray

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::Read() {
  return BitArray::IntrinsicSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<
    Storage>::EmbossReservedDollarVirtualIntrinsicSizeInBytesView::UncheckedRead() {
  return BitArray::IntrinsicSizeInBytes();
}

namespace BitArray {
inline constexpr ::std::int32_t MaxSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace BitArray

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::Read() {
  return BitArray::MaxSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<
    Storage>::EmbossReservedDollarVirtualMaxSizeInBytesView::UncheckedRead() {
  return BitArray::MaxSizeInBytes();
}

namespace BitArray {
inline constexpr ::std::int32_t MinSizeInBytes() {
  return ::emboss::support::Maybe</**/::std::int32_t>(static_cast</**/::std::int32_t>(8LL)).ValueOrDefault();
}
}  // namespace BitArray

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::Read() {
  return BitArray::MinSizeInBytes();
}

template <class Storage>
inline constexpr ::std::int32_t
GenericBitArrayView<
    Storage>::EmbossReservedDollarVirtualMinSizeInBytesView::UncheckedRead() {
  return BitArray::MinSizeInBytes();
}



}  // namespace test



}  // namespace emboss



/* NOLINTEND */

#endif  // TESTDATA_BITS_EMB_H_

